title: 记一次阿里巴巴电面经历
author: Gin
tags: [面试]
categories: [后端]
date: 2021-06-17 21:44:00
---
**前言**：本人有幸在boss直聘上获得一次阿里巴巴国际技术事业部的电话面试机会，由于太突然，大部分问题都没有发挥原来的水平，诶，决定痛下决心好好总结，还有就是坚定下自己的目标=\_=。
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上来先做了个自我介绍，由于要找个信号好的地方，爬到了楼顶，结果气喘吁吁的=_=，下面就开始提问一些专业的问题。
#### 1.面向对象的封装，继承，多态的含义
- 封装是指将对象的细节隐藏起来，然后通过公共的方法来向外暴露该对象的功能；
一般来说封装是使用private修饰符对属性进行包装，使用getter/setter对属性进行获取与修改，但是也可以使用setter对属性进行更加深层次的设置，包括你可以对设置的格式做转化，对数据的要求；
- 继承是面向对象实现软件复用的重要手段，子类继承父类，子类就拥有父类的成员属性和成员办法，可以拥有父类的功能，也可以对父类的方法进行重写（覆盖）；缺点是违背了高内聚，低耦合的编程思想，耦合程度比较高，并且破坏了封装的特性，可见部分功能的丧失来换取另一部功能的完整。
- 多态可以理解为同一个行为有不同的表达形式或者形态的能力，举个例子，父类可以是Animals类，具有say()方法行为，但是对于不同种类动物手说的话是不同的，比如Cat类，可能说"喵喵喵"，Dog类说"汪汪汪"之类的；多态实现的条件是上具备一些以上的条件的：
1）继承；2）重写；3）向上转型；
#### 2.抽象类和接口的区别

- 这个算是老生常谈的问题了，大概有以下几点：
- 抽象类中可以有普通的方法和成员变量，而接口中的办法必须是抽象的，变量也必须是static final类型的（其实就是常量），必须被初始化，接口中只有常量，没有变量；
- 抽象类中的方法可以不全为抽象方法，子类继承可以不必全部实现，全部实现为普通类，不全部实现还是抽象类，而实现接口的类必须实现其中的方法；
- 抽象类拥有类的特性，单继承，而接口多继承；
- Java8 中接口中会有 default 方法，即方法可以被实现。

#### 3.内存溢出和内存泄露的含义，举例说明，不超过10行代码；
- 内存泄露的概念是指对象可达，但是没用了，就是本该被CG回收的那些没有被回收；内存泄露的原因有以下2点：
1）长周期对象引用短周期对象；
2）没有将无用对象置为null；
举一个第一个情况的例子：

    >Static Vector v = new Vector(10); 
    for (int i = 1; i<100; i++) 
    { 
    &nbsp;&nbsp;Object o = new Object(); 
    &nbsp;&nbsp;v.add(o); 
    &nbsp;&nbsp;o = null; 
    }

内存泄露可以造成内存溢出，是造成内存溢出的一种情况，内存泄露积累起来将导致内存溢出。
#### 4.对Spring IOC的理解
spring IOC 的ioc是inverse of controller的英文缩写，意思是控制反转的意思，spring ioc有3种注入方式：
- 基于属性的注入；
eg:<bean>标签下配置<property name="xxxx(属性名称)" value/ref="xxxx(属性值/依赖注入的bean)">
这种注入前提是注入的bean要有默认实现的setter方法；
- 基于构造器的注入；
eg:<bean> 标签下配置<constructor-arg ref="引用的bean id">
前提是该bean注入的值是引用的bean对象类型，另外还可以是基本数据类型的注入，包括集合；
eg:
**基本数据类型**:

        <constructor-arg index="0" type="java.lang.String" value="1"/></constructor-arg>
        <constructor-arg index="1" type="java.lang.Integer" value="2"></constructor-arg>

**集合**:

    <bean id="xxxx" class="com.xxxx.xxxx" >
    		<property name="arrayData">
    			<array/list/set>
    				<value>xxx</value>
    				<value>aaa</value>
    				<value>bbb</value>
    				<value>ccc</value>
    			</array/list/set>
    		</property>
    </bean>
    <property name="mapData">
    	<map>
    		<entry key="jack" value="杰克"></entry>
    		<entry>
    			<key><value>rose</value></key>
    			<value>肉丝</value>
    		</entry>
    	</map>
    </property>
    
    <property name="propsData">
    	<props>
    		<prop key="xxxx">xxxx</prop>
    		<prop key="aaaa">aaaa</prop>
    		<prop key="bbbb">bbbb</prop>
    	</props>
    </property>
- 基于注解的注入；
使用注解实现ioc的方法，首先记得要配置spring context 的命名空间，并且在applicationContext.xml中配置扫描的含有注解的包；
eg:

      <context:component-scan base-package="xxx.xxxx.xxxx"/>

#### 5.Spring aop的理解，底层实现原理

以下给出一段代码解释：
当实现日志控制时，

        //将织入类交给spring bean处理
        <bean id="loggingAspect" class="com.cyy.maven.core.Aspect.LoggingAspect"/>
        <aop:config>
            //定义切入点
            <aop:pointcut id="serviceOpearation" expression="execution(* com.cyy.maven.core.service.impl.*.*(..))"/>
            //引用切入点
            <aop:aspect  ref="loggingAspect">
            //使用切入点中的方法织入
                <aop:before method="beforeMethod" pointcut-ref="serviceOpearation"/>
                <aop:after method="afterMethod" pointcut-ref="serviceOpearation"/>
                <aop:after-returning method="afterReturning" pointcut-ref="serviceOpearation" returning="result"/>
                <aop:after-throwing method="afterThrowing" pointcut-ref="serviceOpearation" throwing="e"/>
                //环绕方法，等价于以上4个的作用
                <aop:around method="aroundMethod" pointcut-ref="serviceOpearation"/>
            </aop:aspect>
        </aop:config>

#### 6.&nbsp;Set和Map的区别
- Set是Collection接口下的子接口，Set中的数据可以是无序的，不可以重复，Set的形式是set<type>  myset，即节点是一个type类型的数据；
- Map 是跟Collection同级别的集合接口，Map的形式是map<type1,type2> mymap,即节点数据是一对数据，以键值对的形式存在，key唯一，value可以重复；
最基础的回答可以是这样，以后会专门写一篇来对集合这种数据类型进行深入浅出的研究；


#### 7.&nbsp;对数据库索引的理解，会举例考察你
这个可以参考我之前写过的一篇文章[Mysql 索引的具体优化策略](https://www.jianshu.com/p/b82f2926d9e5)
#### 8.&nbsp;方法覆盖和重载的区别
- 方法覆盖又叫方法重写，是重写父类的办法，权限不能更小，抛出的异常不能更多；
- 重载是同一个类中可以有相同名字的方法，但是由于方法参数的类型，顺序，个数不尽相同的相同名称的方法；

#### 9.&nbsp;数据库事务的4个特性，最好能说出详细的特征
这个可以参考我之前写过的一篇文章[spring 事务理解](https://www.jianshu.com/p/3e7c12a1a2be)
#### 10.&nbsp;讲讲数据结构中的栈，堆，队列的理解（就是对各种数据结构的理解）
#### 11.&nbsp;10000个String对象的去重
**tips**: 可以使用HashSet解决；
#### 12.&nbsp;String对象的取值范围
定长的String数据类型占用的存储空间为字符串的长度，取值范围为1——65400个字符;
#### 13&nbsp;TCP建立连接 3次握手，结束时4次挥手原理具体内容
#### 14.&nbsp;ThreadLocal使用过吗，你来说说对它的理解
#### 15.&nbsp;说说数据库内连接，左外连接，右外连接的理解
这个可以参考我之前写过的一篇文章[mysql 连接](https://www.jianshu.com/p/83d84d7df306)
####16.&nbsp;Session和Cookie的区别
####17.&nbsp;StringBuffer和StringBuild的区别和含义
- StringBuffer:每次都对对象本身进行操作，而不是生成新的对象。所以在字符串内容不断改变的情况，建议使用StringBuffer。
- String对象的字符串拼接其实是被JVM解释成了StringBuffer对象的拼接，所以这些时候String对象的速度并不会比StringBuffer慢。
- StringBuild: 区别在于,StringBuffer是线程安全的类。StringBuild不是线程安全的类，在单线程中性能要比StringBuffrer高。

#### 18.&nbsp;熟悉设计模式吗，说说你对java设计模式的了解
#### 19.&nbsp;mysql  in 和exists的区别
这个可以参考我之前写过的一篇文章[MySQL中exists和in的区别及使用场景](https://www.jianshu.com/p/2138cbdeea34)
#### 20.&nbsp;请介绍你参与的印象最深刻的一个项目，为什么？并且介绍你在项目中的角色和发挥的作用
#### 21.&nbsp;你对我们有什么想要提问的吗









