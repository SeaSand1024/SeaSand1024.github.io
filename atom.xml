<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mr_Chen</title>
  
  <subtitle>yyds</subtitle>
  <link href="https://seasand1024.github.io/atom.xml" rel="self"/>
  
  <link href="https://seasand1024.github.io/"/>
  <updated>2021-06-17T14:15:26.333Z</updated>
  <id>https://seasand1024.github.io/</id>
  
  <author>
    <name>Gin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一个你不会认识的陌生人</title>
    <link href="https://seasand1024.github.io/2021/06/17/%E4%B8%80%E4%B8%AA%E4%BD%A0%E4%B8%8D%E4%BC%9A%E8%AE%A4%E8%AF%86%E7%9A%84%E9%99%8C%E7%94%9F%E4%BA%BA/"/>
    <id>https://seasand1024.github.io/2021/06/17/%E4%B8%80%E4%B8%AA%E4%BD%A0%E4%B8%8D%E4%BC%9A%E8%AE%A4%E8%AF%86%E7%9A%84%E9%99%8C%E7%94%9F%E4%BA%BA/</id>
    <published>2021-06-17T14:13:25.000Z</published>
    <updated>2021-06-17T14:15:26.333Z</updated>
    
    <content type="html"><![CDATA[<p>漫长的时光里</p><p>你独自一个人度过</p><p>生命总是孤独</p><p>你总是默默承受</p><p>即使每一个过客</p><p>终究有谢幕离场的时分</p><p>我是一个你不会认识的陌生人</p><p>你是一道我永远也遇不上的彩虹</p><p>没有遇上方知有</p><p>好在花有清香月有阴</p><p>我们在不同的世界</p><p>演绎着类似的人生</p><p>陌生的旧情人</p><p>你是谁的新欢和旧爱</p><p>而我只是一个</p><p>你不会认识的陌生人</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;漫长的时光里&lt;/p&gt;
&lt;p&gt;你独自一个人度过&lt;/p&gt;
&lt;p&gt;生命总是孤独&lt;/p&gt;
&lt;p&gt;你总是默默承受&lt;/p&gt;
&lt;p&gt;即使每一个过客&lt;/p&gt;
&lt;p&gt;终究有谢幕离场的时分&lt;/p&gt;
&lt;p&gt;我是一个你不会认识的陌生人&lt;/p&gt;
&lt;p&gt;你是一道我永远也遇不上的彩虹&lt;/p&gt;
&lt;p&gt;没有</summary>
      
    
    
    
    <category term="现代诗" scheme="https://seasand1024.github.io/categories/现代诗/"/>
    
    
    <category term="诗歌" scheme="https://seasand1024.github.io/tags/诗歌/"/>
    
  </entry>
  
  <entry>
    <title>鄉愁</title>
    <link href="https://seasand1024.github.io/2021/06/17/%E9%84%89%E6%84%81/"/>
    <id>https://seasand1024.github.io/2021/06/17/%E9%84%89%E6%84%81/</id>
    <published>2021-06-17T14:08:00.000Z</published>
    <updated>2021-06-17T14:09:22.762Z</updated>
    
    <content type="html"><![CDATA[<p>芦苇飘荡的季节﻿</p><p>少年将沉沉的离别披在肩上﻿</p><p>乡愁像芦苇荡里的水一样柔﻿</p><p>遗忘的日子里﻿</p><p>心中总是若有所思﻿</p><p>乡愁像渔家的灯火一样引人入眠﻿</p><p>岁月像车轮一般轧过如路面荒芜的日子﻿</p><p>远处月台橘黄色的站台灯碰弯了旅人的思绪﻿</p><p>恍惚流失的光阴迷失在记忆的岔道口﻿</p><p>春日大海的阳光照耀着北回归线﻿</p><p>视野里的芦苇叶子眯成一线﻿</p><p>蓝的海黑的海 逐渐缩成点的海鸥﻿</p><p>露水闪透着晶莹的清晨﻿</p><p>列车经过铁轨吸进一个个影子后逝去﻿</p><p>乡愁像一曲永不停息的曲子﻿</p><p>在风尘苦旅的夜里奏起</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;芦苇飘荡的季节﻿&lt;/p&gt;
&lt;p&gt;少年将沉沉的离别披在肩上﻿&lt;/p&gt;
&lt;p&gt;乡愁像芦苇荡里的水一样柔﻿&lt;/p&gt;
&lt;p&gt;遗忘的日子里﻿&lt;/p&gt;
&lt;p&gt;心中总是若有所思﻿&lt;/p&gt;
&lt;p&gt;乡愁像渔家的灯火一样引人入眠﻿&lt;/p&gt;
&lt;p&gt;岁月像车轮一般轧过如路面荒芜的日子﻿&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="现代诗" scheme="https://seasand1024.github.io/categories/现代诗/"/>
    
    
    <category term="诗歌" scheme="https://seasand1024.github.io/tags/诗歌/"/>
    
  </entry>
  
  <entry>
    <title>無題</title>
    <link href="https://seasand1024.github.io/2021/06/17/%E7%84%A1%E9%A1%8C/"/>
    <id>https://seasand1024.github.io/2021/06/17/%E7%84%A1%E9%A1%8C/</id>
    <published>2021-06-17T14:07:00.000Z</published>
    <updated>2021-06-17T14:07:28.855Z</updated>
    
    <content type="html"><![CDATA[<p>就像没说完的一段故事</p><p>就像断了的弦</p><p>孤寂在夜空盘旋</p><p>旅人在灯下行走</p><p>车辆穿梭于漆黑的夜</p><p>喧嚣隐去于沉睡的异世界</p><p>圆月下的立交桥路面</p><p>水银镜一般映射光华</p><p>深夜的路灯</p><p>独自闷不吭声</p><p>光线四处逃窜</p><p>疲惫不堪的倒在地上</p><p>摸索着所有能触及的黑暗</p><p>潮水在离森林不远处翻滚声息</p><p>萤火虫于溪岸跃动身影</p><p>追寻</p><p>自黄昏到黑夜</p><p>流动的城市灯火</p><p>停留于指尖瞬间</p><p>抑或</p><p>雨中潮湿的羽翼</p><p>在遥远的空中挥动</p><p>在视野中渐行渐远</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;就像没说完的一段故事&lt;/p&gt;
&lt;p&gt;就像断了的弦&lt;/p&gt;
&lt;p&gt;孤寂在夜空盘旋&lt;/p&gt;
&lt;p&gt;旅人在灯下行走&lt;/p&gt;
&lt;p&gt;车辆穿梭于漆黑的夜&lt;/p&gt;
&lt;p&gt;喧嚣隐去于沉睡的异世界&lt;/p&gt;
&lt;p&gt;圆月下的立交桥路面&lt;/p&gt;
&lt;p&gt;水银镜一般映射光华&lt;/p&gt;
&lt;p&gt;深夜的路灯</summary>
      
    
    
    
    <category term="现代诗" scheme="https://seasand1024.github.io/categories/现代诗/"/>
    
    
    <category term="诗歌" scheme="https://seasand1024.github.io/tags/诗歌/"/>
    
  </entry>
  
  <entry>
    <title>新辞</title>
    <link href="https://seasand1024.github.io/2021/06/17/%E6%96%B0%E8%BE%9E/"/>
    <id>https://seasand1024.github.io/2021/06/17/%E6%96%B0%E8%BE%9E/</id>
    <published>2021-06-17T14:01:56.000Z</published>
    <updated>2021-06-17T14:03:17.898Z</updated>
    
    <content type="html"><![CDATA[<p>歌管楼台声细细，秋千院落夜沉沉。</p><p>徒有斜阳与人语，不念故乡念旧人。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;歌管楼台声细细，秋千院落夜沉沉。&lt;/p&gt;
&lt;p&gt;徒有斜阳与人语，不念故乡念旧人。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="古风拾迹" scheme="https://seasand1024.github.io/categories/古风拾迹/"/>
    
    
    <category term="诗歌" scheme="https://seasand1024.github.io/tags/诗歌/"/>
    
  </entry>
  
  <entry>
    <title>Mysql 索引的具体优化策略</title>
    <link href="https://seasand1024.github.io/2021/06/17/Mysql-%E7%B4%A2%E5%BC%95%E7%9A%84%E5%85%B7%E4%BD%93%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/"/>
    <id>https://seasand1024.github.io/2021/06/17/Mysql-%E7%B4%A2%E5%BC%95%E7%9A%84%E5%85%B7%E4%BD%93%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/</id>
    <published>2021-06-17T13:58:26.000Z</published>
    <updated>2021-06-17T13:59:15.052Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言</strong>：Mysql索引的底层实现原理包括数据结构和不同的mysql引擎下索引的实现方式会在另一篇文章中详细描写，这里主要讨论的是具体优化策略体现。</p><p>####1. 导入<br>这里的数据库示例用mysql的官方数据库<a href="https://dev.mysql.com/doc/employee/en/employees-installation.html" target="_blank" rel="noopener">employees</a>做演示，现在git上把项目clone到本地，按照mysql的官方文档进行导入（这里不做具体解释）。导入完后的数据库ER图具体如下：<br><img src="https://upload-images.jianshu.io/upload_images/10224563-45e4cc03129ed99b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>####2. 最左前缀原理和相关优化</p><ul><li>首先可以查看employees数据库titles都有哪些索引<blockquote><p>SHOW INDEX FROM employees.titles;<br><img src="https://upload-images.jianshu.io/upload_images/10224563-cc44fd8c9f7b2653.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></blockquote></li><li>进行全列匹配的索引优化</li></ul><blockquote><p>EXPLAIN SELECT * FROM employees.titles WHERE emp_no=’10001’ AND title=’Senior Engineer’ AND from_date=’1986-06-26’;<br><img src="https://upload-images.jianshu.io/upload_images/10224563-4504c92892def3aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></blockquote><p>很明显，当按照索引中所有列进行精确匹配（这里精确匹配指“=”或“IN”匹配）时，索引可以被用到。这里有一点需要注意，理论上索引对顺序是敏感的，但是由于MySQL的查询优化器会自动调整where子句的条件顺序以使用适合的索引，例如我们将where中的条件顺序颠倒：</p><blockquote><p>EXPLAIN SELECT * FROM employees.titles WHERE from_date=’1986-06-26’ AND emp_no=’10001’ AND title=’Senior Engineer’;<br><img src="https://upload-images.jianshu.io/upload_images/10224563-d020984801980a97.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></blockquote><p>结果是一样的。</p><ul><li>最左前缀匹配</li></ul><blockquote><p>EXPLAIN SELECT * FROM employees.titles WHERE emp_no=’10001’;<br><img src="https://upload-images.jianshu.io/upload_images/10224563-d1734f04eb662bd4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></blockquote><p>当查询条件精确匹配索引的左边连续一个或几个列时，如&lt;emp_no&gt;或&lt;emp_no, title&gt;，所以可以被用到，但是只能用到一部分，即条件所组成的最左前缀。上面的查询从分析结果看用到了PRIMARY索引，但是key_len为4，说明只用到了索引的第一列前缀。</p><ul><li>查询条件用到了索引中列的精确匹配，但是中间某个条件未提供。<blockquote><p>EXPLAIN SELECT * FROM employees.titles WHERE emp_no=’10001’ AND from_date=’1986-06-26’;<br><img src="https://upload-images.jianshu.io/upload_images/10224563-9c77d2a698d41dc7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></blockquote></li></ul><p>此时索引使用情况和情况二相同，因为title未提供，所以查询只用到了索引的第一列，而后面的from_date虽然也在索引中，但是由于title不存在而无法和左前缀连接，因此需要对结果进行扫描过滤from_date（这里由于emp_no唯一，所以不存在扫描）。如果想让from_date也使用索引而不是where过滤，可以增加一个辅助索引&lt;emp_no, from_date&gt;，此时上面的查询会使用这个索引。除此之外，还可以使用一种称之为“隔离列”的优化方法，将emp_no与from_date之间的“坑”填上。</p><p>查看下title一共有几种不同的值：</p><blockquote><p>SELECT DISTINCT(title) FROM employees.titles;<br><img src="https://upload-images.jianshu.io/upload_images/10224563-37d8a8fd146786bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></blockquote><p>在这种成为“坑”的列值比较少的情况下，可以考虑用“IN”来填补这个“坑”从而形成最左前缀：</p><blockquote><p>EXPLAIN SELECT * FROM employees.titles<br>WHERE emp_no=’10001’<br>AND title IN (‘Senior Engineer’, ‘Staff’, ‘Engineer’, ‘Senior Staff’, ‘Assistant Engineer’, ‘Technique Leader’, ‘Manager’)<br>AND from_date=’1986-06-26’;<br><img src="https://upload-images.jianshu.io/upload_images/10224563-d4ca4d8f0d64a15d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></blockquote><p>这次key_len为59，说明索引被用全了，但是从type和rows看出IN实际上执行了一个range查询，这里检查了7个key。看下两种查询的性能比较：</p><blockquote><p>SHOW PROFILES(这句话的开启具体见<a href="https://www.cnblogs.com/binyue/p/4645278.html" target="_blank" rel="noopener">这里</a>);<br><img src="https://upload-images.jianshu.io/upload_images/10224563-5410d96ad7176623.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></blockquote><p>“填坑”后性能提升了一点。如果经过emp_no筛选后余下很多数据，则后者性能优势会更加明显。当然，如果title的值很多，用填坑就不合适了，必须建立辅助索引。</p><ul><li>查询条件没有指定索引第一列。<blockquote><p>EXPLAIN SELECT * FROM employees.titles WHERE from_date=’1986-06-26’;<br><img src="https://upload-images.jianshu.io/upload_images/10224563-21746f17ceb280d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></blockquote></li></ul><p>由于不是最左前缀，索引这样的查询显然用不到索引。</p><ul><li>匹配某列的前缀字符串。<blockquote><p>EXPLAIN SELECT * FROM employees.titles WHERE emp_no=’10001’ AND title LIKE ‘Senior%’;<br><img src="https://upload-images.jianshu.io/upload_images/10224563-401134b8f07c46e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></blockquote></li></ul><p>此时可以用到索引，如果通配符%不出现在开头，则可以用到索引，但根据具体情况不同可能只会用其中一个前缀。</p><ul><li>范围查询。</li></ul><blockquote><p>EXPLAIN SELECT * FROM employees.titles WHERE emp_no &lt; ‘10010’ and title=’Senior Engineer’;<br><img src="https://upload-images.jianshu.io/upload_images/10224563-b64a39145ac12926.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></blockquote><p>范围列可以用到索引（必须是最左前缀），但是范围列后面的列无法用到索引。同时，索引最多用于一个范围列，因此如果查询条件中有两个范围列则无法全用到索引。</p><blockquote><p>EXPLAIN SELECT * FROM employees.titles<br>WHERE emp_no &lt; ‘10010’<br>AND title=’Senior Engineer’<br>AND from_date BETWEEN ‘1986-01-01’ AND ‘1986-12-31’;<br><img src="https://upload-images.jianshu.io/upload_images/10224563-50d9787670fd9f67.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></blockquote><p>可以看到索引对第二个范围索引无能为力。这里特别要说明MySQL一个有意思的地方，那就是仅用explain可能无法区分范围索引和多值匹配，因为在type中这两者都显示为range。同时，用了“between”并不意味着就是范围查询，例如下面的查询：</p><blockquote><p>EXPLAIN SELECT * FROM employees.titles<br>WHERE emp_no BETWEEN ‘10001’ AND ‘10010’<br>AND title=’Senior Engineer’<br>AND from_date BETWEEN ‘1986-01-01’ AND ‘1986-12-31’;<br><img src="https://upload-images.jianshu.io/upload_images/10224563-28294aabdcd0ebcd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></blockquote><p>看起来是用了两个范围查询，但作用于emp_no上的“BETWEEN”实际上相当于“IN”，也就是说emp_no实际是多值精确匹配。可以看到这个查询用到了索引全部三个列。因此在MySQL中要谨慎地区分多值匹配和范围匹配，否则会对MySQL的行为产生困惑。</p><ul><li>查询条件中含有函数或表达式。</li></ul><blockquote><p>EXPLAIN SELECT * FROM employees.titles WHERE emp_no=’10001’ AND left(title, 6)=’Senior’;<br><img src="https://upload-images.jianshu.io/upload_images/10224563-d0a27360c122966f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></blockquote><p>虽然这个查询和情况五中功能相同，但是由于使用了函数left，则无法为title列应用索引，而情况五中用LIKE则可以。再如：</p><blockquote><p>EXPLAIN SELECT * FROM employees.titles WHERE emp_no - 1=’10000’;<br><img src="https://upload-images.jianshu.io/upload_images/10224563-241d6ebae51777f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></blockquote><p>显然这个查询等价于查询emp_no为10001的函数，但是由于查询条件是一个表达式，MySQL无法为其使用索引。看来MySQL还没有智能到自动优化常量表达式的程度，因此在写查询语句时尽量避免表达式出现在查询中，而是先手工私下代数运算，转换为无表达式的查询语句。</p><p>####3.如何选择索引和使用前缀索引<br>&nbsp;&nbsp;&nbsp;&nbsp;如何建立索引可以根据一条公式决定：</p><blockquote><p>######Index Selectivity = Cardinality / #T<br>其中Selectivity是索引的选择性指数，显然范围在（0,1]之间，Cardinality是指不重复的数据，也叫基数，#T是表的记录数，选择性指数越高建立索引的价值就越高（由B+Tree的性质决定的）；可以验证上面employees.titles表的title字段选择性指数数值：<br><img src="https://upload-images.jianshu.io/upload_images/10224563-e9090f77202275e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></blockquote><p>title的选择性不足0.0001（精确值为0.00001579），所以实在没有什么必要为其单独建索引。<br>可以多试几个数据，比如employees.salaries表的salary字段：<br><img src="https://upload-images.jianshu.io/upload_images/10224563-b7b0ab46eca3cfb4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有一种与索引选择性有关的索引优化策略叫做前缀索引，就是用列的前缀代替整个列作为索引key，当前缀长度合适时，可以做到既使得前缀索引的选择性接近全列索引，同时因为索引key变短而减少了索引文件的大小和维护开销。下面以employees.employees表为例介绍前缀索引的选择和使用。</p><p>查询employees表的索引可得：</p><blockquote><p>SHOW INDEX FROM employees.employees;<br><img src="https://upload-images.jianshu.io/upload_images/10224563-347586f49822bb49.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></blockquote><p>只有主键emp_no一个索引，搜索人名比较麻烦,做全表扫描:</p><blockquote><p>EXPLAIN SELECT * FROM employees.employees WHERE first_name=’Eric’ AND last_name=’Anido’;<br><img src="https://upload-images.jianshu.io/upload_images/10224563-558df6c160859f5a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></blockquote><p>如果频繁按名字搜索员工，这样显然效率很低，因此我们可以考虑建索引。有两种选择，建&lt;first_name&gt;或&lt;first_name, last_name&gt;，看下两个索引的选择性：</p><blockquote><p>SELECT count(DISTINCT(first_name))/count(*) AS Selectivity FROM employees.employees;<br><img src="https://upload-images.jianshu.io/upload_images/10224563-fb24654acc406d52.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></blockquote><blockquote><p>SELECT count(DISTINCT(concat(first_name, last_name)))/count(*) AS Selectivity FROM employees.employees;<br><img src="https://upload-images.jianshu.io/upload_images/10224563-933b3da0cc778bd9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></blockquote><p>&lt;first_name, last_name&gt;选择性很好，但是first_name和last_name加起来长度为30,可以考虑用first_name和last_name的前几个字符建立索引，例如&lt;first_name, left(last_name, 3)&gt;，看看其选择性：</p><blockquote><p>SELECT count(DISTINCT(concat(first_name, left(last_name, 3))))/count(*) AS Selectivity FROM employees.employees;<br><img src="https://upload-images.jianshu.io/upload_images/10224563-e2c12045fd8fd094.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></blockquote><p>可以尝试把last_name前缀加到4：</p><blockquote><p>SELECT count(DISTINCT(concat(first_name, left(last_name, 4))))/count(*) AS Selectivity FROM employees.employees;<br><img src="https://upload-images.jianshu.io/upload_images/10224563-92a51386d3355253.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></blockquote><p>这时选择性已经很理想了，而这个索引的长度只有18，比&lt;first_name, last_name&gt;短了接近一半，我们把这个前缀索引 建上：</p><blockquote><p>ALTER TABLE employees.employees<br>ADD INDEX `first_name_last_name4` (first_name, last_name(4));<br><img src="https://upload-images.jianshu.io/upload_images/10224563-0aed7b6b0101e3d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></blockquote><blockquote><p>SHOW PROFILES;<br><img src="https://upload-images.jianshu.io/upload_images/10224563-229aa6a225ecdd9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前缀索引兼顾索引大小和查询速度，但是其缺点是不能用于ORDER BY和GROUP BY操作，也不能用于Covering index（即当索引本身包含查询所需全部数据时，不再访问数据文件本身）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;：Mysql索引的底层实现原理包括数据结构和不同的mysql引擎下索引的实现方式会在另一篇文章中详细描写，这里主要讨论的是具体优化策略体现。&lt;/p&gt;
&lt;p&gt;####1. 导入&lt;br&gt;这里的数据库示例用mysql的官方数据库&lt;a href</summary>
      
    
    
    
    <category term="后端" scheme="https://seasand1024.github.io/categories/后端/"/>
    
    
    <category term="mysql" scheme="https://seasand1024.github.io/tags/mysql/"/>
    
    <category term="索引" scheme="https://seasand1024.github.io/tags/索引/"/>
    
  </entry>
  
  <entry>
    <title>Mysql之索引的基本概念语法</title>
    <link href="https://seasand1024.github.io/2021/06/17/Mysql%E4%B9%8B%E7%B4%A2%E5%BC%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E8%AF%AD%E6%B3%95/"/>
    <id>https://seasand1024.github.io/2021/06/17/Mysql%E4%B9%8B%E7%B4%A2%E5%BC%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E8%AF%AD%E6%B3%95/</id>
    <published>2021-06-17T13:55:56.000Z</published>
    <updated>2021-06-17T13:57:42.960Z</updated>
    
    <content type="html"><![CDATA[<p>####1.Mysql中索引的概念<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MySQL索引的建立对于MySQL的高效运行是很重要的，索引可以大大提高MySQL的检索速度。打个比方，如果合理的设计且使用索引的MySQL是一辆兰博基尼的话，那么没有设计和使用索引的MySQL就是一个人力三轮车。创建索引时，你需要确保该索引是应用在SQL 查询语句的条件(一般作为 WHERE 子句的条件)。 实际上，索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录。</p><p>######索引一般分为：主键索引、唯一索引、普通索引、全文索引、组合索引<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面都在说使用索引的好处，但过多的使用索引将会造成滥用。因此索引也会有它的缺点：虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。建立索引会占用磁盘空间的索引文件。</p><p>####2.索引的基本创建，删除以及数据库表的修改</p><p>#####单列索引的基本创建格式是：<br>CREATE （UNQIUE）INDEX +索引名称+ON+表名（列名（长度））<br>例如：create unique index ac on sys_user(account);</p><p>#####修改表结构的方式创建索引：<br>ALTER TABLE+表名+ADD(UNIQUE) INDEX+索引名称(列名)<br>例如：alter table sys_user add unique index pa(password);</p><p>#####或者也可以创建表的时候指明：<br>    CREATE TABLE sys_user(<br>    id INT NOT NULL primary key,<br>    account VARCHAR(16) NOT NULL,<br>    password VARCHAR(32) NOT NULL,<br>    INDEX ac (account (16))<br>    );  </p><p>#####删除索引的语法：<br>DROP INDEX 索引名称 ON 表 或者 alter table 表名 drop index 索引名;<br>例如：drop index pa on sys_user;&amp; alter table sys_user drop index pa;</p><p>#####显示索引信息:<br>格式：SHOW INDEX FROM 表名;<br>SHOW INDEX FROM sys_user;<br><img src="https://upload-images.jianshu.io/upload_images/10224563-2af9d972939f6a7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;####1.Mysql中索引的概念&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;MySQL索引的建立对于MySQL的高效运行是很重要的，索引可以大大提高MySQL的检索速度。打个比方，如果合理的设计且使用索引的MySQL是一辆兰</summary>
      
    
    
    
    <category term="后端" scheme="https://seasand1024.github.io/categories/后端/"/>
    
    
    <category term="mysql" scheme="https://seasand1024.github.io/tags/mysql/"/>
    
    <category term="索引" scheme="https://seasand1024.github.io/tags/索引/"/>
    
  </entry>
  
  <entry>
    <title>浅谈java基础之JVM</title>
    <link href="https://seasand1024.github.io/2021/06/17/%E6%B5%85%E8%B0%88java%E5%9F%BA%E7%A1%80%E4%B9%8BJVM/"/>
    <id>https://seasand1024.github.io/2021/06/17/%E6%B5%85%E8%B0%88java%E5%9F%BA%E7%A1%80%E4%B9%8BJVM/</id>
    <published>2021-06-17T13:54:54.000Z</published>
    <updated>2021-06-17T13:55:38.332Z</updated>
    
    <content type="html"><![CDATA[<p>####1.java实现跨平台的原理。</p><ul><li>java实现跨平台的原理是基于JVM实现的，即Java Virtual Machine,对于不同机器平台有不同的JVM版本（JVM本身是用C/C++实现的），通过模拟一台计算机来达到一个计算机所具有的计算功能，底层都是运行编译器生成的java字节码文件，实现了 “一次编译，到处运行” 的目的。<br>总结： JVM 屏蔽了与各个计算机平台相关的软件或者硬件之间的差异，使得与平台相关的耦合统一由 JVM 提供者来实现<br>####2.JVM的组成以及各部分详解<br>JVM的基本结构是由4部分组成的：</li><li>类加载器，在 JVM 启动时或者类运行时将需要的 class 加载到 JVM 中；</li><li>执行引擎，执行引擎负责执行class文件包含的字节码指令，相当于机器的CPU；</li><li>内存区，将内存划分成若干个区域，模拟机器上上的存储，记录和调度功能模块，比如各种功能的寄存器和PC指针记录器；</li><li>本地方法调用，调用C/C++实现的本地代码的返回结果；<br><img src="https://upload-images.jianshu.io/upload_images/10224563-59034e35b9037bf9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>####3.类加载器基本原理<br>类加载器（class loader），用来加载java类到虚拟机中。一般来说，java虚拟机使用java的过程如下：java源程序经过java编译器转化之后变化成java字节码文件。类加载器负责读取java字节码文件，并转化成java.lang.Class的一个实例，每个实例就是一个java类,通过实例的newInstance()方法生成该类的一个对象，或者使用java动态代理生成的会有更复杂的过程，或者通过网络下载的。<br>####补充：java判断2个对象的过程<br>第一步查看类名是否相同，第二步查看类加载器是否相同，只有2者都是相同的情况下才会被认为2者是相同的。具体来说，可以在不同包里面新建2个相同类名的类，进行编译运行测试，判断2者是否属于相同，判断对象是否相同可以用.equal()方法；<br>####4.类加载器加载class文件的详细过程<br><img src="https://upload-images.jianshu.io/upload_images/10224563-b8cb7ca912749afc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li><li>第一阶段找到这个class文件，并且 把它加载到内存中；</li><li>第二阶段分为3个小步骤，即<ul><li>字节码验证；</li><li>class类数据分析；</li><li>相应的内存分配与符号链接；</li></ul></li><li>第三个阶段是静态属性和初始化赋值，静态代码块的执行；<h5 id="（1）-加载阶段的详细分析"><a href="#（1）-加载阶段的详细分析" class="headerlink" title="（1） 加载阶段的详细分析"></a>（1） 加载阶段的详细分析</h5>查找并加载类的二进制数据时的类加载的第一个阶段，即加载阶段需要执行3个操作：</li><li>通过一个类的全限定名称来获取其定义的二进制流；</li><li>将二进制的静态存储结构转化为方法区的运行时数据结构；</li><li>在java堆中生成一个这个类的java.lang.Class对象，作为对方法区中的这些数据的访问入口。</li></ul><p>相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。</p><p>加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个 java.lang.Class类的对象，这样便可以通过该对象访问方法区中的这些数据。</p><p>#####（2）连接阶段详细分析</p><p> ######验证：确保被加载的类的正确性</p><p>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作：</p><ul><li>文件格式验证：验证字节流是否符合Class文件格式的规范；例如：是否以 0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</li><li>元数据验证：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了 java.lang.Object之外。</li><li>字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</li><li>符号引用验证：确保解析动作能正确执行。</li></ul><p>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用 -Xverifynone 参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p><p>######准备：为类的静态变量分配内存，并将其初始化为默认值<br>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：</p><ul><li>这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。</li><li>这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。</li></ul><p>假设一个类变量的定义为： public static int value = 3;</p><p>那么变量value在准备阶段过后的初始值为 0，而不是 3，因为这时候尚未开始执行任何 Java 方法，而把 value 赋值为 3 的public static指令是在程序编译后，存放于类构造器 <clinit>（）方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。</clinit></p><blockquote><p>这里还需要注意如下几点：</p><ul><li>对基本数据类型来说，对于类变量（static）和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。</li><li>对于同时被static和final修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被final修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。</li><li>对于引用数据类型reference来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即null。</li><li>如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。</li><li>如果类字段的字段属性表中存在 ConstantValue 属性，即同时被 final 和 static 修饰，那么在准备阶段变量 value 就会被初始化为 ConstValue 属性所指定的值。</li></ul></blockquote><p>假设上面的类变量 value 被定义为： public static final int value = 3;</p><p>编译时 Javac 将会为 value 生成 ConstantValue 属性，在准备阶段虚拟机就会根据 ConstantValue 的设置将 value 赋值为 3。我们可以理解为 static final 常量在编译期就将其结果放入了调用它的类的常量池中。</p><p>######解析：把类中的符号引用转换为直接引用</p><p>#####（3）初始化阶段详细分析<br>初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：</p><ul><li>声明类变量是指定初始值</li><li>使用静态代码块为类变量指定初始值</li></ul><p>JVM初始化步骤</p><ul><li>假如这个类还没有被加载和连接，则程序先加载并连接该类</li><li>假如该类的直接父类还没有被初始化，则先初始化其直接父类</li><li>假如类中有初始化语句，则系统依次执行这些初始化语句</li></ul><p>类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的<br>主动使用包括以下六种：</p><ul><li>创建类的实例，也就是new的方式</li><li>访问某个类或接口的静态变量，或者对该静态变量赋值</li><li>调用类的静态方法</li><li>反射（如 Class.forName(“com.shengsiyuan.Test”)）</li><li>初始化某个类的子类，则其父类也会被初始化</li><li>Java虚拟机启动时被标明为启动类的类（ JavaTest），直接使用 java.exe命令来运行某个主类</li></ul><p>######结束生命周期<br>在如下几种情况下，Java虚拟机将结束生命周期</p><ul><li>执行了 System.exit()方法</li><li>程序正常执行结束</li><li>程序在执行过程中遇到了异常或错误而异常终止</li><li>由于操作系统出现错误而导致Java虚拟机进程终止</li></ul><p>####5.双亲委派模型（Parent Delegation Model）<br>类的加载过程采用双亲委派机制，这种机制能更好的保证 Java 平台的安全性。<br>类加载器 ClassLoader 是具有层次结构的，也就是父子关系，其中，Bootstrap 是所有类加载器的父亲，如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/10224563-247d5c507d8494e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><blockquote><p>该模型要求除了顶层的 Bootstrap class loader 启动类加载器外，其余的类加载器都应当有自己的父类加载器。子类加载器和父类加载器不是以继承（Inheritance）的关系来实现，而是通过组合（Composition）关系来复用父加载器的代码。每个类加载器都有自己的命名空间（由该加载器及所有父类加载器所加载的类组成，在同一个命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类；在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类）。</p></blockquote><p>双亲委派模型的工作过程如下：</p><ul><li>当前 ClassLoader 首先从自己已经加载的类中查询是否此类已经加载，如果已经加载则直接返回原来已经加载的类。<blockquote><p>每个类加载器都有自己的加载缓存，当一个类被加载了以后就会放入缓存，等下次加载的时候就可以直接返回了。</p></blockquote></li><li>当前 ClassLoader 的缓存中没有找到被加载的类的时候，委托父类加载器去加载，父类加载器采用同样的策略，首先查看自己的缓存，然后委托父类的父类去加载，一直到 bootstrap ClassLoader。<blockquote><p>当所有的父类加载器都没有加载的时候，再由当前的类加载器加载，并将其放入它自己的缓存中，以便下次有加载请求的时候直接返回。</p></blockquote></li></ul><p>这样设计的原因：</p><blockquote><p>这是对于使用这种模型来组织累加器的好处；主要是为了安全性，避免用户自己编写的类动态替换 Java 的一些核心类，比如 String，同时也避免了重复加载，因为 JVM 中区分不同类，不仅仅是根据类名，相同的 class 文件被不同的 ClassLoader 加载就是不同的两个类，如果相互转型的话会抛java.lang.ClassCaseException。</p></blockquote><p>####6.JVM内存管理</p><p>#####（1）内存划分<br><img src="https://upload-images.jianshu.io/upload_images/10224563-2b40e6da3a433ed9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>1.方法区（线程共享）：各个线程共享的一个区域，用于存储虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却又一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。</p><ul><li>运行时常量池：是方法区的一部分，用于存放编译器生成的各种字面量和符号引用。</li></ul><p>2.堆内存（线程共享）：所有线程共享的一块区域，垃圾收集器管理的主要区域。目前主要的垃圾回收算法都是分代收集算法，所以 Java 堆中还可以细分为：新生代和老年代；再细致一点的有 Eden 空间、From Survivor 空间、To Survivor 空间等，默认情况下新生代按照8:1:1的比例来分配。根据 Java 虚拟机规范的规定，Java 堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘一样；</p><p>3.程序计数器： Java 线程私有，类似于操作系统里的 PC 计数器，它可以看做是当前线程所执行的字节码的行号指示器。如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是 Native 方法，这个计数器值则为空（Undefined）。此内存区域是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域；</p><p>4.虚拟机栈（栈内存）：Java线程私有，虚拟机展描述的是Java方法执行的内存模型：每个方法在执行的时候，都会创建一个栈帧用于存储局部变量、操作数、动态链接、方法出口等信息；每个方法调用都意味着一个栈帧在虚拟机栈中入栈到出栈的过程；</p><p>5.本地方法栈 ：和Java虚拟机栈的作用类似，区别是该区域为 JVM 提供使用 native 方法的服务；</p><p>作者：我没有三颗心脏<br>链接：<a href="https://www.jianshu.com/p/bfb876565a1e" target="_blank" rel="noopener">https://www.jianshu.com/p/bfb876565a1e</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;####1.java实现跨平台的原理。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;java实现跨平台的原理是基于JVM实现的，即Java Virtual Machine,对于不同机器平台有不同的JVM版本（JVM本身是用C/C++实现的），通过模拟一台计算机来达到一个计算机所具有的计算功能</summary>
      
    
    
    
    <category term="后端" scheme="https://seasand1024.github.io/categories/后端/"/>
    
    
    <category term="java" scheme="https://seasand1024.github.io/tags/java/"/>
    
    <category term="JVM" scheme="https://seasand1024.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>java之静态代码块与构造方法加载次序</title>
    <link href="https://seasand1024.github.io/2021/06/17/java%E4%B9%8B%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E4%B8%8E%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%8A%A0%E8%BD%BD%E6%AC%A1%E5%BA%8F/"/>
    <id>https://seasand1024.github.io/2021/06/17/java%E4%B9%8B%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E4%B8%8E%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%8A%A0%E8%BD%BD%E6%AC%A1%E5%BA%8F/</id>
    <published>2021-06-17T13:54:07.000Z</published>
    <updated>2021-06-17T13:54:35.753Z</updated>
    
    <content type="html"><![CDATA[<ul><li>java中的静态代码块，非静态块，构造办法的加载顺序是这样的：<br>静态代码块 （程序加载时一次）—&gt;非静态块（每次实例化一次）—&gt; 构造方法（每次实例化一次），废话不多说，上代码。</li></ul><p>#####A类：</p><blockquote><pre><code>public class A {    static {        System.out.print(&quot;1&quot;);    }     {        System.out.print(&quot;#&quot;);    }    public A(){        System.out.print(&quot;a&quot;);    }}</code></pre></blockquote><p>#####B类：</p><blockquote><pre><code>/** * @Author: Cyy * @Description: * @Date:Created in 16:08 2018/7/28 */public class B extends A {    static {        System.out.print(&quot;2&quot;);    }     {        System.out.print(&quot;*&quot;);    }    public B(){        System.out.print(&quot;b&quot;);    }    {        System.out.print(&quot;c&quot;);    }    public static void main(String[] args) {//        A a=new A();//结果12a,执行一次2个静态区代码，执行非静态代码块，再执行A的构造办法//        B b=new B();//结果12ab,执行一次2个静态区代码，执行非静态代码块，再依次执行A和B的构造办法        A ab=new B();//同上        ab=new B();//此时静态代码块已经加载,只加载一次，执行非静态代码块，是每次实例化都一次，跟构造方法一样，比构造办法先，输出非静态代码和构造办法的部分    }}</code></pre></blockquote><p>我们尝试运行，看看结果：<br><img src="https://upload-images.jianshu.io/upload_images/10224563-039c5928d44ca760.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>结果是12#a*b#a*b,来分析下整个流程：</p><ul><li>第一步按顺序加载2个类的静态代码块，程序载入时，只会执行一次，输出12；</li><li>第二步按顺序分别加载A类和B类的非静态代码块以及构造方法，输出#a*b;</li><li>第三步，再次实例化B类的时候，不在静态代码块了，只会加载非静态代码块和构造方法，再次输出结果#a*b;</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;java中的静态代码块，非静态块，构造办法的加载顺序是这样的：&lt;br&gt;静态代码块 （程序加载时一次）—&amp;gt;非静态块（每次实例化一次）—&amp;gt; 构造方法（每次实例化一次），废话不多说，上代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;#####A类：&lt;/p&gt;
&lt;bloc</summary>
      
    
    
    
    <category term="后端" scheme="https://seasand1024.github.io/categories/后端/"/>
    
    
    <category term="java" scheme="https://seasand1024.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>spring 事务理解</title>
    <link href="https://seasand1024.github.io/2021/06/17/spring-%E4%BA%8B%E5%8A%A1%E7%90%86%E8%A7%A3/"/>
    <id>https://seasand1024.github.io/2021/06/17/spring-%E4%BA%8B%E5%8A%A1%E7%90%86%E8%A7%A3/</id>
    <published>2021-06-17T13:52:51.000Z</published>
    <updated>2021-06-17T13:53:06.943Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-事务的概念"><a href="#1-事务的概念" class="headerlink" title="1.事务的概念"></a>1.事务的概念</h3><p> 通俗的讲，事务指的是一组业务操作ABCD，要么全部成功，要么全部不成功。</p><h3 id="2-关系数据库的事务的特性-ACID"><a href="#2-关系数据库的事务的特性-ACID" class="headerlink" title="2.关系数据库的事务的特性(ACID)"></a>2.关系数据库的事务的特性(ACID)</h3><ul><li>原子性(Atomicity)：事务是数据库的逻辑工作单位，而且是必须是原子工作单位，对于修改，要么全部执行，要么全部不执行。</li><li>一致性(Consistency)：事务在完成时，必须是所有的数据都保持一致状态。在相关数据库中，所有规则都必须应用于事务的修改，以保持所有数据的完整性。</li><li>隔离性(Isolation)：一个事务的执行不能被其他事务所影响。事务必须是互相隔离的，防止并发读写同一个数据的情况发生 。</li><li><p>持久性(Durability) : 一个事务一旦提交，事物的操作便永久性的保存在DB中。即使此时再执行回滚操作也不能撤消所做的更改。</p><h3 id="3-spring事务的隔离级别"><a href="#3-spring事务的隔离级别" class="headerlink" title="3.spring事务的隔离级别"></a>3.spring事务的隔离级别</h3></li><li><p>ISOLATION_DEFAULT  –使用数据库默认的事务隔离级别。</p><ul><li><p>ISOLATION_READ_UNCOMMITTED  –这是事务最低的隔离级别，它充许令外一个事务可以看到这个事务未提交的数据(<strong>读未提交</strong>)。</p></li><li><p>ISOLATION_READ_COMMITTED  –保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据(<strong>读已提交</strong>)。</p></li><li><p>ISOLATION_REPEATABLE_READ  –这种事务隔离级别可以防止脏读，不可重复读。但是可能出现幻像读(<strong>虚读</strong>)。</p></li><li><p>ISOLATION_SERIALIZABLE  –这是花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。除了防止脏读，不可重复读外，还避免了幻像读(<strong>序列化</strong>)。</p></li></ul></li></ul><p>理解Spring事务的隔离级别，需要明白的几个概念：</p><ul><li>脏读（脏数据）: 指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据， 那么另外一个事务读到的这个数据是脏数据，依据脏数据所做的操作可能是不正确的。</li><li>不可重复读: 指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。</li><li>幻觉读: 指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。<h3 id="4-Spring事务的传播属性（Propagation）"><a href="#4-Spring事务的传播属性（Propagation）" class="headerlink" title="4.Spring事务的传播属性（Propagation）"></a>4.Spring事务的传播属性（Propagation）</h3></li><li><p>PROPAGATION_REQUIRED  –支持当前事务，如果当前没有事务，就新建一个事务，一般默认采用此配置。</p></li><li><p>PROPAGATION_SUPPORTS  –支持当前事务，如果当前没有事务，就以非事务方式执行。</p></li><li><p>PROPAGATION_MANDATORY  –支持当前事务，如果当前没有事务，就抛出异常。</p></li><li><p>PROPAGATION_REQUIRES_NEW  –新建事务，如果当前存在事务，把当前事务挂起。</p></li><li><p>PROPAGATION_NOT_SUPPORTED  –以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</p></li><li><p>PROPAGATION_NEVER  –以非事务方式执行，如果当前存在事务，则抛出异常。</p><h3 id="5-JDBC事务的隔离级别"><a href="#5-JDBC事务的隔离级别" class="headerlink" title="5.JDBC事务的隔离级别"></a>5.JDBC事务的隔离级别</h3></li><li><p>TRANSACTION_NONE  –不支持事务，实际项目中很少使用。</p></li><li><p>TRANSACTION_READ_UNCOMMITTED  –在提交前一个事务可以看到另一个事务的变化。脏读、不可重复的读和幻觉读都是允许的。</p></li><li><p>TRANSACTION_READ_COMMITTED  –读取未提交的数据是不允许的。这个级别仍然允许不可重复的读和虚读产生。</p></li><li><p>TRANSACTION_REPEATABLE_READ  –事务保证能够再次读取相同的数据而不会失败，但虚读仍然会出现。</p></li><li><p>TRANSACTION_SERIALIZABLE  –最高的事务级别，它防止脏读、不可重复的读和虚读。</p></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/10224563-5d3e594331d0c758.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="$LBPYPLJ89T4Z~VED9O)9@E.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-事务的概念&quot;&gt;&lt;a href=&quot;#1-事务的概念&quot; class=&quot;headerlink&quot; title=&quot;1.事务的概念&quot;&gt;&lt;/a&gt;1.事务的概念&lt;/h3&gt;&lt;p&gt; 通俗的讲，事务指的是一组业务操作ABCD，要么全部成功，要么全部不成功。&lt;/p&gt;
&lt;h3 id=&quot;</summary>
      
    
    
    
    <category term="后端" scheme="https://seasand1024.github.io/categories/后端/"/>
    
    
    <category term="事务" scheme="https://seasand1024.github.io/tags/事务/"/>
    
    <category term="spring" scheme="https://seasand1024.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>spring aop模式管理数据库事务</title>
    <link href="https://seasand1024.github.io/2021/06/17/spring-aop%E6%A8%A1%E5%BC%8F%E7%AE%A1%E7%90%86%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/"/>
    <id>https://seasand1024.github.io/2021/06/17/spring-aop%E6%A8%A1%E5%BC%8F%E7%AE%A1%E7%90%86%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/</id>
    <published>2021-06-17T13:52:12.000Z</published>
    <updated>2021-06-17T13:52:29.654Z</updated>
    
    <content type="html"><![CDATA[<p>####1.搭建项目环境，基于idea下maven环境的搭建，此处贴出pom文件的jar包依赖：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;  &lt;groupId&gt;com.cyy&lt;/groupId&gt;  &lt;artifactId&gt;spring_aop&lt;/artifactId&gt;  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;  &lt;name&gt;spring_aop&lt;/name&gt;  &lt;!-- FIXME change it to the project&apos;s website --&gt;  &lt;url&gt;http://www.example.com&lt;/url&gt;  &lt;properties&gt;    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;    &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;    &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;    &lt;spring.version&gt;4.3.12.RELEASE&lt;/spring.version&gt;  &lt;/properties&gt;  &lt;dependencies&gt;    &lt;dependency&gt;      &lt;groupId&gt;junit&lt;/groupId&gt;      &lt;artifactId&gt;junit&lt;/artifactId&gt;      &lt;version&gt;4.11&lt;/version&gt;      &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;      &lt;version&gt;${spring.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;aopalliance&lt;/groupId&gt;      &lt;artifactId&gt;aopalliance&lt;/artifactId&gt;      &lt;version&gt;1.0&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.aspectj&lt;/groupId&gt;      &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt;      &lt;version&gt;1.8.11&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;      &lt;version&gt;${spring.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;      &lt;version&gt;${spring.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;      &lt;version&gt;${spring.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;mysql&lt;/groupId&gt;      &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;      &lt;version&gt;5.1.42&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;c3p0&lt;/groupId&gt;      &lt;artifactId&gt;c3p0&lt;/artifactId&gt;      &lt;version&gt;0.9.1.2&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;      &lt;version&gt;${spring.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-core&lt;/artifactId&gt;      &lt;version&gt;${spring.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-context&lt;/artifactId&gt;      &lt;version&gt;${spring.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-expression&lt;/artifactId&gt;      &lt;version&gt;${spring.version}&lt;/version&gt;    &lt;/dependency&gt;  &lt;/dependencies&gt;  &lt;build&gt;    &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt;      &lt;plugins&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt;          &lt;version&gt;3.0.0&lt;/version&gt;        &lt;/plugin&gt;        &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_jar_packaging --&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;          &lt;version&gt;3.0.2&lt;/version&gt;        &lt;/plugin&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;          &lt;version&gt;3.7.0&lt;/version&gt;        &lt;/plugin&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;          &lt;version&gt;2.20.1&lt;/version&gt;        &lt;/plugin&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;          &lt;version&gt;3.0.2&lt;/version&gt;        &lt;/plugin&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt;          &lt;version&gt;2.5.2&lt;/version&gt;        &lt;/plugin&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt;          &lt;version&gt;2.8.2&lt;/version&gt;        &lt;/plugin&gt;      &lt;/plugins&gt;    &lt;/pluginManagement&gt;  &lt;/build&gt;&lt;/project&gt;</code></pre><p>具体的搭建项目步骤，自行百度解决。</p><p>####2.转账事务环境搭建：<br>1）创建表和各个类与接口：</p><pre><code>create database ee19_spring_day03;use ee19_spring_day03;create table account(  id int primary key auto_increment,  username varchar(50),  money int);insert into account(username,money) values(&apos;jack&apos;,&apos;10000&apos;);insert into account(username,money) values(&apos;rose&apos;,&apos;10000&apos;);</code></pre><ul><li>新建service层和dao层以及各自下面的impl层</li><li><p>在dao下面新建AccountDao接口，代码如下：</p><pre><code>package com.cyy.dao;/** * @Author: Cyy * @Description: * @Date:Created in 22:37 2018/8/1 */public interface AccountDao {    public void out(String outer, Integer money) ;    public void in(String inner, Integer money) ;}</code></pre></li><li><p>在dao下的impl下新建实现类AccountDaoImpl，继承自JdbcDaoSupport，实现其中的方法：</p><pre><code>package com.cyy.dao.impl;import com.cyy.dao.AccountDao;import org.springframework.jdbc.core.support.JdbcDaoSupport;/** * @Author: Cyy * @Description: * @Date:Created in 22:37 2018/8/1 */public class AccountDaoImpl extends JdbcDaoSupport implements AccountDao {    @Override    public void out(String outer, Integer money) {        this.getJdbcTemplate().update(&quot;update account set money = money - ? where username = ?&quot;, money,outer);    }    @Override    public void in(String inner, Integer money) {        this.getJdbcTemplate().update(&quot;update account set money = money + ? where username = ?&quot;, money,inner);    }}</code></pre></li><li><p>新建service下AccountService接口：</p><pre><code>package com.cyy.service;/** * @Author: Cyy * @Description: * @Date:Created in 22:40 2018/8/1 */public interface AccountService {    public void transfer(String outer, String inner, Integer money);}</code></pre></li><li><p>新建service.impl下AccountServiceImpl实现类：</p><pre><code>package com.cyy.service.impl;import com.cyy.dao.AccountDao;import com.cyy.service.AccountService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;/** * @Author: Cyy * @Description: * @Date:Created in 22:40 2018/8/1 */public class AccountServiceImpl  implements AccountService{</code></pre></li></ul><pre><code>    public void setAccountDao(AccountDao accountDao) {        this.accountDao = accountDao;    }    private AccountDao accountDao;    @Override    public void transfer(String outer, String inner, Integer money) {        // TODO Auto-generated method stub        accountDao.out(outer, money);        //断电//        int i = 1 / 0;        accountDao.in(inner, money);    }}</code></pre><p>2）完善配置文件</p><ul><li>在main下新建与java的同级目录resources，并且标记为Resources Root;</li><li>在resources下新建spring上下文文件applicationContext.xml，配置初始配置内容如下：</li></ul><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd        http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.1.xsd       http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.1.xsd&quot;&gt;    &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;        &lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driver}&quot;/&gt;        &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.url}&quot;/&gt;        &lt;property name=&quot;user&quot; value=&quot;${jdbc.username}&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt;    &lt;/bean&gt;    &lt;bean id=&quot;accountDao&quot; class=&quot;com.cyy.dao.impl.AccountDaoImpl&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;    &lt;/bean&gt;    &lt;bean id=&quot;accountService&quot; class=&quot;com.cyy.service.impl.AccountServiceImpl&quot;&gt;        &lt;property name=&quot;accountDao&quot; ref=&quot;accountDao&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><ul><li>在resources下新建jdbc.properties配置文件：</li></ul><pre><code>jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/ee19_spring_day03jdbc.username=rootjdbc.password=</code></pre><p>3）测试文件的配置</p><ul><li>在main同级的test文件下的java下新建test文件（其实已经maven自动生成了），如图：<br><img src="https://upload-images.jianshu.io/upload_images/10224563-f0a8e95d111c2c32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li></ul><p>配置代码：</p><pre><code>package com.cyy;import com.cyy.service.AccountService;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * Unit test for simple App. */public class AppTest {    /**     * Rigorous Test :-)     */    @Test    public void demo01(){        String xmlPath = &quot;applicationContext.xml&quot;;        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(xmlPath);        AccountService accountService =  (AccountService) applicationContext.getBean(&quot;accountService&quot;);        accountService.transfer(&quot;rose&quot;, &quot;jack&quot;, 1000);    }}</code></pre><p>####3.测试运行<br>原本数据库jack和rose的money都是10000的：<br><img src="https://upload-images.jianshu.io/upload_images/10224563-ac72d8c125bc3062.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>此处在AccountServiceImpl暂时注销掉了<br>  //        int i = 1 / 0;<br>先保证事务的正确运行查看效果，点击运行AppTest类：<br><img src="https://upload-images.jianshu.io/upload_images/10224563-ab28af911bfe3aac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>测试通过，再来查看数据库：<br><img src="https://upload-images.jianshu.io/upload_images/10224563-749472f82639c604.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>已经成功实现了转账1000块的功能，这次把  //        int i = 1 / 0;注释去掉，<br>并且恢复数据库原本数值，再次点击AppTest类运行：<br><img src="https://upload-images.jianshu.io/upload_images/10224563-9fe139292e669e3f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>异常报错，再去查看数据库：<br><img src="https://upload-images.jianshu.io/upload_images/10224563-5a2104cf2c23e421.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>事务没有正确回滚，导致事务的ACID特性被破坏，所以接下来，我们将通过几种方式实现事务的管理。</p><p>####4.手动事务管理</p><ul><li>修改AccountService接口：</li></ul><pre><code>package com.cyy.service;/** * @Author: Cyy * @Description: * @Date:Created in 22:40 2018/8/1 */public interface AccountService {//    public void transfer(String outer, String inner, Integer money);    public void transfer(final String outer,final String inner,final Integer money);}</code></pre><ul><li>将AccountServiceImpl中原来的transfer注释掉，添加以下代码：</li></ul><pre><code>private TransactionTemplate transactionTemplate;public void setTransactionTemplate(TransactionTemplate transactionTemplate) {    this.transactionTemplate = transactionTemplate;}@Overridepublic void transfer(final String outer,final String inner,final Integer money) {    transactionTemplate.execute(new TransactionCallbackWithoutResult() {        @Override        protected void doInTransactionWithoutResult(TransactionStatus arg0) {            accountDao.out(outer, money);            //断电              int i = 1/0;            accountDao.in(inner, money);        }    });}</code></pre><ul><li>修改applicationContext.xml配置文件：</li></ul><pre><code>&lt;bean id=&quot;accountService&quot; class=&quot;com.cyy.service.impl.AccountServiceImpl&quot;&gt;    &lt;property name=&quot;accountDao&quot; ref=&quot;accountDao&quot;/&gt;    &lt;property name=&quot;transactionTemplate&quot; ref=&quot;transactionTemplate&quot;/&gt;&lt;/bean&gt;&lt;!-- 手动模式，使用TransactionTemplate --&gt; &lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;transactionTemplate&quot; class=&quot;org.springframework.transaction.support.TransactionTemplate&quot;&gt;    &lt;property name=&quot;transactionManager&quot; ref=&quot;txManager&quot;/&gt;&lt;/bean&gt;</code></pre><ul><li>再次点击AppTest类运行测试，运行结果：</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/10224563-48ab6b16ab8d2df0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>如期报错,再去查看数据库：<br><img src="https://upload-images.jianshu.io/upload_images/10224563-dcdf6ad87573eace.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>如期实现了手动的事务管理，通过spring底层使用 TransactionTemplate 事务模板进行操作。</p><p>####5.代理工厂实现的事务管理</p><ul><li>修改AccountService接口和AccountServiceImpl类以及applicationContext.xml为原本的配置；</li></ul><p>然后新增如下配置：</p><pre><code> &lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;   &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt;    &lt;bean id=&quot;proxyAccountService&quot; class=&quot;org.springframework.transaction.interceptor.TransactionProxyFactoryBean&quot;&gt;    &lt;property name=&quot;proxyInterfaces&quot; value=&quot;com.cyy.service.AccountService&quot;/&gt;    &lt;property name=&quot;target&quot; ref=&quot;accountService&quot;/&gt;    &lt;property name=&quot;transactionManager&quot; ref=&quot;txManager&quot;/&gt;    &lt;property name=&quot;transactionAttributes&quot;&gt;        &lt;props&gt;            &lt;prop key=&quot;transfer&quot;&gt;PROPAGATION_REQUIRED,ISOLATION_DEFAULT&lt;/prop&gt;        &lt;/props&gt;    &lt;/property&gt;&lt;/bean&gt;    </code></pre><ul><li><p>在AppTest中新建demo2方法：</p><pre><code>@Testpublic void demo02(){    String xmlPath = &quot;applicationContext.xml&quot;;    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(xmlPath);    AccountService accountService =  (AccountService) applicationContext.getBean(&quot;proxyAccountService&quot;);    accountService.transfer(&quot;jack&quot;, &quot;rose&quot;, 1000);}</code></pre></li><li><p>测试结果：</p></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/10224563-6f94344b6dcf4d61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>一样报错，但是数据库没有实现错误转账，如图：</p><p><img src="https://upload-images.jianshu.io/upload_images/10224563-ba3ab6d571d669c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>####6.基于xml的aop事务配置</p><ul><li><p>修改applicationContext.xml配置文件：</p><pre><code> &lt;!--事务管理器的配置--&gt;  &lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;&lt;/bean&gt; &lt;!-- 基于xml的aop事务配置 --&gt; &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;txManager&quot;&gt;     &lt;tx:attributes&gt;         &lt;tx:method name=&quot;transfer&quot; propagation=&quot;REQUIRED&quot; isolation=&quot;DEFAULT&quot;/&gt;     &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;aop:config&gt;     &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut=&quot;execution(* com.cyy.service.impl.*.*(..))&quot;/&gt; &lt;/aop:config&gt;</code></pre></li><li><p>运行测试AppTest类的demo1()方法：</p></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/10224563-218e84e6ecb0e0a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>数据库：<br><img src="https://upload-images.jianshu.io/upload_images/10224563-9640bee658b2336a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>####7.基于注解的aop事务配置</p><ul><li><p>在applicationContext.xml中将以上代理类的配置替换成</p><pre><code>&lt;tx:annotation-driven transaction-manager=&quot;txManager&quot;/&gt;</code></pre></li><li><p>在需要进行事务操作的类或者方法上进行加上注解 @Transactional，同时可以配置事务传播级别和事务隔离级别，例如：</p><pre><code>@Transactional(propagation = Propagation.REQUIRED,isolation = Isolation.DEFAULT)</code></pre></li></ul><p>简单解释一下，这里的传播级别设置的是REQUIRED,即支持当前事务，如果当前没有事务，就新建一个事务，一般默认采用此配置;隔离级别DEFAULT，使用数据库默认的事务隔离级别（MySQL 事务默认隔离级别是可重复读）。</p><ul><li>再次查看测试结果：<br><img src="https://upload-images.jianshu.io/upload_images/10224563-fea1db5aaed45a0d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li></ul><p>报错，数据库：<br><img src="https://upload-images.jianshu.io/upload_images/10224563-c891d9eec4750387.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;####1.搭建项目环境，基于idea下maven环境的搭建，此处贴出pom文件的jar包依赖：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;

&amp;lt;pro</summary>
      
    
    
    
    <category term="后端" scheme="https://seasand1024.github.io/categories/后端/"/>
    
    
    <category term="java" scheme="https://seasand1024.github.io/tags/java/"/>
    
    <category term="spring" scheme="https://seasand1024.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>spring之aop配置与springboot aop配置</title>
    <link href="https://seasand1024.github.io/2021/06/17/spring%E4%B9%8Baop%E9%85%8D%E7%BD%AE%E4%B8%8Espringboot-aop%E9%85%8D%E7%BD%AE/"/>
    <id>https://seasand1024.github.io/2021/06/17/spring%E4%B9%8Baop%E9%85%8D%E7%BD%AE%E4%B8%8Espringboot-aop%E9%85%8D%E7%BD%AE/</id>
    <published>2021-06-17T13:51:03.000Z</published>
    <updated>2021-06-17T13:51:50.367Z</updated>
    
    <content type="html"><![CDATA[<p>spring的面向切面编程，即aop编程是有3种作用的：</p><ul><li><p>日志记录</p></li><li><p>安全验证</p></li><li><p>数据库事务管理</p></li></ul><p>这里简单的先讲述下日志的记录体现。</p><p>1.spring的aop配置有基于注解和xml2种，为了方便演示，这里用上次ssm搭建代码来演示，代码地址<a href="https://gitee.com/cyy2csy/ssm。" target="_blank" rel="noopener">https://gitee.com/cyy2csy/ssm。</a></p><p>（1）基于xml的spring aop配置</p><pre><code>新建包Aspect，在下面新建织入类LoggingAspect：</code></pre><p>package com.cyy.maven.core.Aspect;</p><p>import org.aspectj.lang.JoinPoint;</p><p>import org.aspectj.lang.ProceedingJoinPoint;</p><p>import org.aspectj.lang.annotation.*;</p><p>/**</p><ul><li><p>@Author: Cyy</p></li><li><p>@Description: 织入类</p></li><li><p>@Date:Created in 16:00 2018/7/22</p></li></ul><p>*/</p><p>@Slf4j</p><p>public class LoggingAspect {</p><pre><code>public void beforeMethod(JoinPoint joinPoint){String methodName = joinPoint.getSignature().getName();    Object [] args = joinPoint.getArgs();   log.info(&quot;The method={} begins with={}&quot;,methodName,Arrays.asList(args));}</code></pre><p>public void afterMethod(JoinPoint joinPoint){</p><pre><code>String methodName = joinPoint.getSignature().getName();log.info(&quot;The method={} ends&quot;,methodName);}</code></pre><p>  public void afterReturning(JoinPoint joinPoint, Object result){</p><pre><code>String methodName = joinPoint.getSignature().getName();   log.info(&quot;The method={},ends with={}&quot;,methodName,result);}</code></pre><p>public void afterThrowing(JoinPoint joinPoint, Exception e){</p><pre><code>String methodName = joinPoint.getSignature().getName();  log.error(&quot;The method={},occurs excetion:={}&quot;,methodName,e);}</code></pre><p>  public Object aroundMethod(ProceedingJoinPoint pjd){</p><pre><code>Object result =null;    String methodName = pjd.getSignature().getName();    try {        //前置通知      log.info(&quot;The method={},begins with={}&quot;, methodName, Arrays.asList(pjd.getArgs()));        //执行目标方法        result = pjd.proceed();        //返回通知      log.info(&quot;The method={},ends with={}&quot;,methodName ,result);    }catch (Throwable e) {        //异常通知       log.error(&quot;The method={}，occurs exception:={}&quot;,methodName,e);        throw new RuntimeException(e);    }</code></pre><p>//后置通知</p><pre><code>   log.info(&quot;The method={},ends&quot;,methodName);    return result;}</code></pre><p>}<br>在spring的配置文件spring-context.xml中配置基于aop的事务增强。</p><bean id="loggingAspect" class="com.cyy.maven.core.Aspect.LoggingAspect"><p><a href="aop:config" target="_blank" rel="noopener">aop:config</a></p><p>&lt;aop:pointcut id=”serviceOpearation” expression=”execution(<em> com.cyy.maven.core.service.impl.</em>.*(..))”/&gt;</p><p>&lt;aop:aspect ref=”loggingAspect”&gt;</p><pre><code>&lt;aop:before method=&quot;beforeMethod&quot; pointcut-ref=&quot;serviceOpearation&quot;/&gt;&lt;aop:after method=&quot;afterMethod&quot; pointcut-ref=&quot;serviceOpearation&quot;/&gt;&lt;aop:after-returning method=&quot;afterReturning&quot; pointcut-ref=&quot;serviceOpearation&quot; returning=&quot;result&quot;/&gt;&lt;aop:after-throwing method=&quot;afterThrowing&quot; pointcut-ref=&quot;serviceOpearation&quot; throwing=&quot;e&quot;/&gt;</code></pre><p>&lt;/aop:aspect&gt;</p><!--<aop:advisor advice-ref=""/>--><p>&lt;/aop:config&gt;<br>测试结果：</p><p>beforeMethod</p><p>afterMethod&amp;afterReturning<br>在spring-context.xml中其实可以直接配置&lt;aop:around method=”aroundMethod” pointcut-ref=”serviceOpearation”/&gt;环绕通知，等价于前面3个办法的功能。</p><p>（2）基于注解的spring aop配置</p><p>LoggingAspect的配置改为如下：</p><p>package com.cyy.maven.core.Aspect;</p><p>import org.aspectj.lang.JoinPoint;</p><p>import org.aspectj.lang.ProceedingJoinPoint;</p><p>import org.aspectj.lang.annotation.*;</p><p>import org.springframework.stereotype.Component;</p><p>import java.util.Arrays;</p><p>/**</p><ul><li><p>@Author: Cyy</p></li><li><p>@Description:</p></li><li><p>@Date:Created in 16:00 2018/7/22</p></li></ul><p>*/</p><p>@Slf4j</p><p>@Aspect</p><p>@Component</p><p>public class LoggingAspect {</p><p>@Pointcut(“execution(<em> com.cyy.maven.core.service.impl.</em>.*(..))”)</p><p>private void log(){}</p><p>@Before(“log()”)</p><p>public void beforeMethod(JoinPoint joinPoint){</p><p>String methodName = joinPoint.getSignature().getName();</p><pre><code>    Object [] args = joinPoint.getArgs();     log.info(&quot;The method={},begins with={}&quot;,methodName,Arrays.asList(args));}</code></pre><p>@After(“log()”)</p><p>public void afterMethod(JoinPoint joinPoint){</p><p>String methodName = joinPoint.getSignature().getName();</p><pre><code>    log.info(&quot;The method={},ends&quot;,methodName);}</code></pre><p>@AfterReturning(pointcut =”log()”,returning =”result”)</p><p>public void afterReturning(JoinPoint joinPoint, Object result){</p><p>String methodName = joinPoint.getSignature().getName();</p><pre><code>  log.info(&quot;The method={},ends with={}&quot;,methodName,result);}</code></pre><p>@AfterThrowing(pointcut =”log()”,throwing =”e”)</p><p>public void afterThrowing(JoinPoint joinPoint, Exception e){</p><p>String methodName = joinPoint.getSignature().getName();</p><pre><code>   log.error(&quot;The method={},occurs excetion:={}&quot;,methodName,e);}</code></pre><p>//    @Around(“log()”)</p><pre><code>public ObjectaroundMethod(ProceedingJoinPoint pjd){</code></pre><p>Object result =null;</p><pre><code>String methodName = pjd.getSignature().getName();try {</code></pre><p>//前置通知</p><pre><code>   log.info(&quot;The method={},begins with={}&quot;, methodName, Arrays.asList(pjd.getArgs()));    //执行目标方法    result = pjd.proceed();    //返回通知   log.info(&quot;The method={},ends with={}&quot;,methodName ,result);}catch (Throwable e) {</code></pre><p>//异常通知</p><pre><code>    log.error(&quot;The method={}，occurs exception:={}&quot;,methodName,e);    throw new RuntimeException(e);}</code></pre><p>//后置通知</p><pre><code>  log.info(&quot;The method={},ends&quot;,methodName);    return result;}</code></pre><p>}</p><p>spring配置文件spring-context.xml的配置如下：</p><!-- 配置自动扫描--><p>&lt;context:component-scan base-package=”com.cyy.maven.core.Aspect”/&gt;</p><!--告诉JVM 我们用了aspectj的 annotation --><p><a href="aop:aspectj-autoproxy/" target="_blank" rel="noopener">aop:aspectj-autoproxy/</a><br>测试结果如图：</p><p>beforeMethod</p><p>afterMethod&amp;afterReturning<br>在aroundMethod加上@Around(“log()”)，注释掉其他的注解，可以实现相同的功能。</p><p>2.springboot的aop配置不用基于xml，是完全基于注解的配置，和spring的注解配置很相似。</p><p>这里也直接用以前搭建的springboot框架来测试，码云地址为<a href="https://gitee.com/cyy2csy/girl.git。" target="_blank" rel="noopener">https://gitee.com/cyy2csy/girl.git。</a></p><p>新建Aspect包，下面新建HttpAspect织入类：</p><p>package com.cyy.Aspect;</p><p>import lombok.extern.slf4j.Slf4j;</p><p>import org.apache.catalina.servlet4preview.http.HttpServletRequest;</p><p>import org.aspectj.lang.JoinPoint;</p><p>import org.aspectj.lang.ProceedingJoinPoint;</p><p>import org.aspectj.lang.annotation.*;</p><p>import org.springframework.stereotype.Component;</p><p>import org.springframework.web.context.request.RequestContextHolder;</p><p>import org.springframework.web.context.request.ServletRequestAttributes;</p><p>@Slf4j</p><p>@Aspect</p><p>@Component</p><p>public class HttpAspect {</p><p>@Pointcut(“execution(public <em> com.cyy.controller.GirlController.</em>(..))”)</p><p>public void log(){}</p><p>@Before(“log()”)</p><p>public void doBefore(JoinPoint joinPoint){</p><p>ServletRequestAttributes attributes= (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</p><pre><code>    HttpServletRequest request= (HttpServletRequest) attributes.getRequest();    log.info(&quot;执行事务之前。。。&quot;);    log.info(&quot;url={}&quot;,request.getRequestURI());    log.info(&quot;method={}&quot;,request.getMethod());    log.info(&quot;ip={}&quot;,request.getRemoteAddr());    log.info(&quot;class-method={}&quot;,joinPoint.getSignature().getDeclaringTypeName()+&quot;.&quot;+joinPoint.getSignature().getName());    log.info(&quot;args={}&quot;,joinPoint.getArgs());}</code></pre><p>@After(“log()”)</p><p>public void doAfter(){</p><p>log.info(“执行事务之后。。。”);</p><pre><code>}</code></pre><p>@AfterReturning(returning =”object”, pointcut =”log()”)</p><p>public void doAfterReturning(Object object) {</p><p>log.info(“response={}”, object.toString());</p><pre><code>}</code></pre><p>@AfterThrowing(pointcut =”log()”,throwing =”e”)</p><p>public void afterThrowing(JoinPoint joinPoint, Exception e){</p><p>String methodName = joinPoint.getSignature().getName();</p><pre><code>  log.info(&quot;The method={}&quot; + methodName +&quot; occurs excetion:={}&quot; + e);}</code></pre><p>//    @Around(“log()”)</p><pre><code>public ObjectaroundMethod(ProceedingJoinPoint pjd){</code></pre><p>Object object =null;</p><pre><code>String methodName = pjd.getSignature().getName();try {</code></pre><p>//前置通知</p><pre><code>    ServletRequestAttributes attributes= (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();    HttpServletRequest request= (HttpServletRequest) attributes.getRequest();    log.info(&quot;执行事务之前。。。&quot;);    log.info(&quot;url={}&quot;,request.getRequestURI());    log.info(&quot;method={}&quot;,request.getMethod());    log.info(&quot;ip={}&quot;,request.getRemoteAddr());    log.info(&quot;class-method={}&quot;,pjd.getSignature().getDeclaringTypeName()+&quot;.&quot;+pjd.getSignature().getName());    log.info(&quot;args={}&quot;,pjd.getArgs());    //执行目标方法    object = pjd.proceed();    //返回通知    log.info(&quot;response={}&quot;, object.toString());}catch (Throwable e) {</code></pre><p>//异常通知</p><pre><code>  log.info(&quot;The method={},occurs exception:={}&quot;,methodName,e);    throw new RuntimeException(e);}</code></pre><p>//后置通知</p><pre><code>    log.info(&quot;执行事务之后。。。&quot;);    return object;}</code></pre><p>}<br>测试结果：</p><p>同样的， 将@Around(“log()”)加上，将其他注解注释掉，运行也是同样的结果。</p></bean>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;spring的面向切面编程，即aop编程是有3种作用的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;日志记录&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;安全验证&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;数据库事务管理&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里简单的先讲述下日志的记录体现。&lt;/p&gt;</summary>
      
    
    
    
    <category term="后端" scheme="https://seasand1024.github.io/categories/后端/"/>
    
    
    <category term="java" scheme="https://seasand1024.github.io/tags/java/"/>
    
    <category term="spring" scheme="https://seasand1024.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>java的3种代理模式</title>
    <link href="https://seasand1024.github.io/2021/06/17/java%E7%9A%843%E7%A7%8D%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>https://seasand1024.github.io/2021/06/17/java%E7%9A%843%E7%A7%8D%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-06-17T13:49:09.000Z</published>
    <updated>2021-06-17T13:50:25.339Z</updated>
    
    <content type="html"><![CDATA[<p>1.静态代理</p><pre><code>静态代理是由代理类使用目标接口的实现类的引用实现的一种代理模式，比如新建目标接口IUserDao，实现类UserDao和，静态代理类StaticUserDaoProxy（静态代理类也要实现相同的接口）。</code></pre><p>IUserDao接口：</p><p>package com.cyy.i.dao;</p><p>/**</p><ul><li><p>@Author: Cyy</p></li><li><p>@Description:接口</p></li><li><p>@Date:Created in 17:00 2018/7/19</p></li></ul><p>*/</p><p>public interface IUserDao {</p><p>void save();</p><p>}<br>UserDao实现类：</p><p>package com.cyy.i.dao.impl;</p><p>import com.cyy.i.dao.IUserDao;</p><p>/**</p><ul><li><p>@Author: Cyy</p></li><li><p>@Description:实现类</p></li><li><p>@Date:Created in 17:01 2018/7/19</p></li></ul><p>*/</p><p>public class UserDaoimplements IUserDao {</p><p>@Override</p><pre><code>public void save() {</code></pre><p>System.out.println(“——已经保存数据！——“);</p><pre><code>}</code></pre><p>}<br>静态代理类StaticUserDaoProxy：</p><p>package com.cyy.i.proxy;</p><p>import com.cyy.i.dao.IUserDao;</p><p>/**</p><ul><li><p>@Author: Cyy</p></li><li><p>@Description: 代理对象，静态代理</p></li><li><p>@Date:Created in 17:05 2018/7/19</p></li></ul><p>*/</p><p>public class StaticUserDaoProxyimplements IUserDao{</p><p>private IUserDaotarget;</p><pre><code>public StaticUserDaoProxy(IUserDao target) {</code></pre><p>this.target = target;</p><pre><code>}</code></pre><p>@Override</p><pre><code>public void save() {</code></pre><p>System.out.println(“执行目标事务前的操作。。。”);</p><pre><code>    target.save();    System.out.println(&quot;执行目标事务后的操作。。。&quot;);}</code></pre><p>}<br>编写一个静态测试办法去主函数调用：</p><p>public static void staticProxy(){</p><p>System.out.println(“—-静态代理—-“);</p><pre><code>IUserDao dao=new UserDao();//静态代理的实质是用代理类引用目标类的实例执行，将原来的办法做二层封装，实现原有事务执行前后的一些操作，即办法的重写，是事先编译好的，生成字节码的代理类。StaticUserDaoProxy daoProxy=new StaticUserDaoProxy(dao);//执行调用daoProxy.save();</code></pre><p>}</p><p>public static void main(String[] args) {</p><pre><code>staticProxy();</code></pre><p>}<br>测试结果：</p><p>静态代理<br>2.jdk动态代理模式</p><pre><code>jdk动态代理模式是通过java的反射机制实现的，避免静态代理下多个接口多种事务需求而需要多写冗余的代码，而且不需要实现目标接口，同上使用相同的目标接口和实现类，只是代理类变成了DynamicUserDaoProxy。</code></pre><p>动态代理类DynamicUserDaoProxy：</p><p>package com.cyy.i.proxy;</p><p>import java.lang.reflect.InvocationHandler;</p><p>import java.lang.reflect.Method;</p><p>import java.lang.reflect.Proxy;</p><p>/**</p><ul><li><p>@Author: Cyy</p></li><li><p>@Description:jdk动态代理类</p></li><li><p>@Date:Created in 17:15 2018/7/19</p></li></ul><p>*/</p><p>public class DynamicUserDaoProxy {</p><p>private Objecttarget;</p><pre><code>public DynamicUserDaoProxy(Object target) {</code></pre><p>this.target = target;</p><pre><code>}</code></pre><p>public ObjectgetProxyInstance(){</p><p>return Proxy.newProxyInstance(</p><p>target.getClass().getClassLoader(),</p><pre><code>target.getClass().getInterfaces(),new InvocationHandler(){</code></pre><p>@Override</p><pre><code>public Objectinvoke(Object proxy, Method method, Object[] args)throws Throwable {</code></pre><p>System.out.println(“执行目标事务前的操作。。。”);</p><pre><code>    Object returnValue=method.invoke(target,args);    System.out.println(&quot;执行目标事务后的操作。。。&quot;);    return returnValue;}</code></pre><p>});</p><pre><code>}</code></pre><p>}<br>同样在主函数添加测试静态方法dynamicProxy():</p><p>public static void dynamicProxy(){</p><p>System.out.println(“—-jdk动态代理—-“);</p><pre><code>IUserDao dao=new UserDao();System.out.println(dao.getClass());IUserDao daoProxy = (IUserDao)new DynamicUserDaoProxy(dao).getProxyInstance();System.out.println(daoProxy.getClass());//执行调用daoProxy.save();</code></pre><p>}</p><p>public static void main(String[] args) {</p><pre><code>staticProxy();dynamicProxy();</code></pre><p>}<br>测试结果:</p><p>jdk动态代理<br>3.基于cglib的动态代理</p><pre><code>基于jdk的动态代理是需要一个实现接口的目标对象，实现单独对象的话要使用cglib的代理。新建一个CUserDao目标类，以及一个代理工厂类ProxyFactory，spring的核心包已经包括cglib的包，这里导入spring-core-4.0.0.RELEASE.jar的版本。</code></pre><p>CUserDao目标类：</p><p>package com.cyy.ni.dao;</p><p>/**</p><ul><li><p>@Author: Cyy</p></li><li><p>@Description: CUserDao目标类</p></li><li><p>@Date:Created in 18:01 2018/7/19</p></li></ul><p>*/</p><p>public class CUserDao {</p><p>public void save() {</p><p>System.out.println(“—-已经保存数据!—-“);</p><pre><code>}</code></pre><p>}<br>代理工厂类ProxyFactory：</p><p>package com.cyy.ni.proxy;</p><p>import org.springframework.cglib.proxy.Enhancer;</p><p>import org.springframework.cglib.proxy.MethodInterceptor;</p><p>import org.springframework.cglib.proxy.MethodProxy;</p><p>import java.lang.reflect.Method;</p><p>/**</p><ul><li><p>@Author: Cyy</p></li><li><p>@Description: 代理工厂类ProxyFactory</p></li><li><p>@Date:Created in 18:01 2018/7/19</p></li></ul><p>*/</p><p>public class ProxyFactoryimplements MethodInterceptor {</p><p>private Objecttarget;</p><pre><code>public ProxyFactory(Object target) {</code></pre><p>this.target = target;</p><pre><code>}</code></pre><p>public ObjectgetProxyInstance() {</p><p>Enhancer en=new Enhancer();</p><pre><code>    en.setSuperclass(target.getClass());    en.setCallback(this);    return en.create();}</code></pre><p>@Override</p><pre><code>public Objectintercept(Object o, Method method, Object[] objects, MethodProxy proxy)throws Throwable {</code></pre><p>System.out.println(“执行目标事务前的操作。。。”);</p><pre><code>    Object reuturnValue = method.invoke(target, objects);    System.out.println(&quot;执行目标事务后的操作。。。&quot;);    return reuturnValue;}</code></pre><p>}<br>主函数中的的静态方法：</p><p>public static void CGlibDynamicProxy(){</p><pre><code>System.out.println(&quot;----CGlib动态代理----&quot;);CUserDao target =new CUserDao();CUserDao proxy = (CUserDao)new ProxyFactory(target).getProxyInstance();System.out.println(proxy.getClass());proxy.save();</code></pre><p>}</p><p>public static void main(String[] args) {</p><pre><code>    CGlibDynamicProxy();}</code></pre><p>测试结果：</p><p>cglib代理<br>4.spring中的代理</p><pre><code>Spring中代理对象可通过xml配置方式获得，也可通过ProxyFactory手动编程方式创建对象。先讲手动编程的方式。Spring中的代理对象其实是JDK Proxy和CGLIB Proxy 的结合。 下面我们新建spring包，新建目标类MyTarget，目标接口PeopleService，它的实现类EnglishService，织入类AroundInteceptor实现aop包下MethodInterceptor的接口，测试类ProxyFactoryTest，这里要导入的几个jar包有spring-aop-4.0.0.RELEASE.jar，aopalliance-1.0.jar，aspectjweaver-1.8.1.jar，commons-logging-1.0.4.jar。</code></pre><p>目标类MyTarget：</p><p>package com.cyy.spring;</p><p>/**</p><ul><li><p>@Author: Cyy</p></li><li><p>@Description: 目标类MyTarget</p></li><li><p>@Date:Created in 19:29 2018/7/19</p></li></ul><p>*/</p><p>public class MyTarget {</p><p>public void printName(){</p><p>System.out.println(“name:Target-“);</p><pre><code>}</code></pre><p>}<br>目标接口PeopleService：</p><p>package com.cyy.spring;</p><p>/**</p><ul><li><p>@Author: Cyy</p></li><li><p>@Description: 目标接口PeopleService</p></li><li><p>@Date:Created in 19:30 2018/7/19</p></li></ul><p>*/</p><p>public interface PeopleService {</p><p>public void sayHello();</p><pre><code>public void printName(String name);</code></pre><p>}<br>实现类EnglishService：</p><p>package com.cyy.spring;</p><p>/**</p><ul><li><p>@Author: Cyy</p></li><li><p>@Description: 实现类EnglishService</p></li><li><p>@Date:Created in 19:34 2018/7/19</p></li></ul><p>*/</p><p>public class EnglishServiceimplements PeopleService {</p><p>@Override</p><pre><code>public void sayHello() {</code></pre><p>System.out.println(“Hi”);</p><pre><code>}</code></pre><p>@Override</p><pre><code>public void printName(String name) {</code></pre><p>System.out.println(“Your name:”+name);</p><pre><code>}</code></pre><p>}<br>织入类AroundInteceptor：</p><p>package com.cyy.spring;</p><p>import org.aopalliance.intercept.MethodInterceptor;</p><p>import org.aopalliance.intercept.MethodInvocation;</p><p>/**</p><ul><li><p>@Author: Cyy</p></li><li><p>@Description: 织入类AroundInteceptor</p></li><li><p>@Date:Created in 19:40 2018/7/19</p></li></ul><p>*/</p><p>public class AroundInteceptorimplements MethodInterceptor {</p><p>@Override</p><pre><code>public Objectinvoke(MethodInvocation methodInvocation)throws Throwable {</code></pre><p>System.out.println(methodInvocation.getMethod().getName()+”调用之前”);</p><pre><code>    Object res=methodInvocation.proceed();    System.out.println(methodInvocation.getMethod().getName()+&quot;调用之后&quot;);    return res;}</code></pre><p>}<br>测试类ProxyFactoryTest：</p><p>package com.cyy.spring;</p><p>import org.junit.Test;</p><p>import org.springframework.aop.framework.ProxyFactory;</p><p>/**</p><ul><li><p>@Author: Cyy</p></li><li><p>@Description: 测试类ProxyFactoryTest</p></li><li><p>@Date:Created in 19:42 2018/7/19</p></li></ul><p>*/</p><p>public class ProxyFactoryTest {</p><p>//没有指定代理类的使用cglib代理</p><p>@Test</p><pre><code>public void classProxy(){    ProxyFactory factory=new ProxyFactory();    factory.setTarget(new MyTarget());    factory.addAdvice(new AroundInteceptor());    MyTarget myTarget = (MyTarget) factory.getProxy();    myTarget.printName();    System.out.println(myTarget.getClass().getName());}</code></pre><p>//指定代理类的使用jdk代理</p><p>@Test</p><pre><code>public void interfaceProxy(){</code></pre><p>ProxyFactory factory=new ProxyFactory();</p><pre><code>    factory.setInterfaces(new Class[]{PeopleService.class});    factory.addAdvice(new AroundInteceptor());    factory.setTarget(new EnglishService());    PeopleService peopleProxy = (PeopleService) factory.getProxy();    peopleProxy.sayHello();    peopleProxy.printName(&quot;cyy&quot;);    System.out.println(peopleProxy.getClass().getName());}</code></pre><p>}<br>测试结果：</p><pre><code>从运行结果的代理类的class name ,以及前两节中讲的，很清晰的看到Spring中对于指定接口的代理类，Spring中使用的是JDK的Proxy，对于不指定接口的使用CGLIB的方式。对于上面的测试方法interfaceProxy，我们只注释掉 </code></pre><p>//factory.setInterfaces(new Class[] { PeopleService.class }) 这行代码，在次运行，结果为：</p><p>使用的是CGLIB处理，从而验证我们的猜想。 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1.静态代理&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;静态代理是由代理类使用目标接口的实现类的引用实现的一种代理模式，比如新建目标接口IUserDao，实现类UserDao和，静态代理类StaticUserDaoProxy（静态代理类也要实现相同的接口）。
&lt;/code&gt;&lt;/pre&gt;</summary>
      
    
    
    
    <category term="后端" scheme="https://seasand1024.github.io/categories/后端/"/>
    
    
    <category term="java" scheme="https://seasand1024.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>idea2017 搭建ssm框架过程</title>
    <link href="https://seasand1024.github.io/2021/06/17/idea2017-%E6%90%AD%E5%BB%BAssm%E6%A1%86%E6%9E%B6%E8%BF%87%E7%A8%8B/"/>
    <id>https://seasand1024.github.io/2021/06/17/idea2017-%E6%90%AD%E5%BB%BAssm%E6%A1%86%E6%9E%B6%E8%BF%87%E7%A8%8B/</id>
    <published>2021-06-17T13:46:32.000Z</published>
    <updated>2021-06-17T13:48:00.128Z</updated>
    
    <content type="html"><![CDATA[<p>环境：</p><pre><code>idea 2017.2.5jdk1.8maven 3.5.0</code></pre><ol><li>新建一个Maven webapp项目</li></ol><p>配置项目groupid,artifactid,version</p><p>2.搭建项目基本架构</p><pre><code>注意，这里自己新建的java文件夹要在设置那里标识成为Source Root,resources 设置为Resource Root。</code></pre><p>3.配置项目项目配置文件，包括mvc配置文件spring-context-mvc.xml，spring Context上下文文件spring-context.xml,mybatis-config.xml全局配置文件，数据库jdbc配置文件，使用的日志框架是logback+lombok,所以有logback配置文件。</p><p>4.接下来配置mybatis动态接口代理，在dao包下新建SysUserDao,entity下新建SysUser，mapper下新建SysUserMapper.xml，在spring-context配置文件里配置如下：</p><p>5.配置web.xml</p><p>6.完善项目结构，方便测试，分别在controller下新建SysUserController，service下新建impl包和SysyUserService接口，impl下新建SysUserServiceImpl，utils下新建MD5Util工具类。</p><pre><code>测试类，测试结果：dao层 </code></pre><p>service层：</p><p>service和dao层基本测试完毕，controller在这里直接启动项目测试，为了方便，直接新建一个json类统一返回；</p><p>返回值为true,并且将用户类返回，说明测试成功。</p><p>7.至此，基本的搭建步骤基本完成，其中一些细节方面的，比如pom依赖的配置，各种配置文件的详细配置，可以参考我码云上的代码，只是一个基本的配置，读者可以根据自己的需求自行改变，在此贴出改项目码云地址：<a href="https://gitee.com/cyy2csy/ssm。" target="_blank" rel="noopener">https://gitee.com/cyy2csy/ssm。</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;环境：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;idea 2017.2.5

jdk1.8

maven 3.5.0
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;新建一个Maven webapp项目&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;配置项目groupid,artifactid,versi</summary>
      
    
    
    
    <category term="后端" scheme="https://seasand1024.github.io/categories/后端/"/>
    
    
    <category term="idea" scheme="https://seasand1024.github.io/tags/idea/"/>
    
    <category term="ssm" scheme="https://seasand1024.github.io/tags/ssm/"/>
    
  </entry>
  
  <entry>
    <title>记一次阿里巴巴电面经历</title>
    <link href="https://seasand1024.github.io/2021/06/17/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E7%94%B5%E9%9D%A2%E7%BB%8F%E5%8E%86/"/>
    <id>https://seasand1024.github.io/2021/06/17/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E7%94%B5%E9%9D%A2%E7%BB%8F%E5%8E%86/</id>
    <published>2021-06-17T13:44:00.000Z</published>
    <updated>2021-06-17T13:45:53.334Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言</strong>：本人有幸在boss直聘上获得一次阿里巴巴国际技术事业部的电话面试机会，由于太突然，大部分问题都没有发挥原来的水平，诶，决定痛下决心好好总结，还有就是坚定下自己的目标=_=。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上来先做了个自我介绍，由于要找个信号好的地方，爬到了楼顶，结果气喘吁吁的=_=，下面就开始提问一些专业的问题。</p><p>####1.面向对象的封装，继承，多态的含义</p><ul><li>封装是指将对象的细节隐藏起来，然后通过公共的方法来向外暴露该对象的功能；<br>一般来说封装是使用private修饰符对属性进行包装，使用getter/setter对属性进行获取与修改，但是也可以使用setter对属性进行更加深层次的设置，包括你可以对设置的格式做转化，对数据的要求；</li><li>继承是面向对象实现软件复用的重要手段，子类继承父类，子类就拥有父类的成员属性和成员办法，可以拥有父类的功能，也可以对父类的方法进行重写（覆盖）；缺点是违背了高内聚，低耦合的编程思想，耦合程度比较高，并且破坏了封装的特性，可见部分功能的丧失来换取另一部功能的完整。</li><li><p>多态可以理解为同一个行为有不同的表达形式或者形态的能力，举个例子，父类可以是Animals类，具有say()方法行为，但是对于不同种类动物手说的话是不同的，比如Cat类，可能说”喵喵喵”，Dog类说”汪汪汪”之类的；多态实现的条件是上具备一些以上的条件的：<br>1）继承；2）重写；3）向上转型；<br>####2.抽象类和接口的区别</p></li><li><p>这个算是老生常谈的问题了，大概有以下几点：</p></li><li>抽象类中可以有普通的方法和成员变量，而接口中的办法必须是抽象的，变量也必须是static final类型的（其实就是常量），必须被初始化，接口中只有常量，没有变量；</li><li>抽象类中的方法可以不全为抽象方法，子类继承可以不必全部实现，全部实现为普通类，不全部实现还是抽象类，而实现接口的类必须实现其中的方法；</li><li>抽象类拥有类的特性，单继承，而接口多继承；</li><li>Java8 中接口中会有 default 方法，即方法可以被实现。</li></ul><p>####3.内存溢出和内存泄露的含义，举例说明，不超过10行代码；</p><ul><li><p>内存泄露的概念是指对象可达，但是没用了，就是本该被CG回收的那些没有被回收；内存泄露的原因有以下2点：<br>1）长周期对象引用短周期对象；<br>2）没有将无用对象置为null；<br>举一个第一个情况的例子：</p><blockquote><p>Static Vector v = new Vector(10);<br>  for (int i = 1; i&lt;100; i++)<br>  {<br>  &nbsp;&nbsp;Object o = new Object();<br>  &nbsp;&nbsp;v.add(o);<br>  &nbsp;&nbsp;o = null;<br>  }</p></blockquote></li></ul><p>内存泄露可以造成内存溢出，是造成内存溢出的一种情况，内存泄露积累起来将导致内存溢出。</p><p>####4.对Spring IOC的理解<br>spring IOC 的ioc是inverse of controller的英文缩写，意思是控制反转的意思，spring ioc有3种注入方式：</p><ul><li>基于属性的注入；<br>eg:<bean>标签下配置&lt;property name=”xxxx(属性名称)” value/ref=”xxxx(属性值/依赖注入的bean)”&gt;<br>这种注入前提是注入的bean要有默认实现的setter方法；</bean></li><li><p>基于构造器的注入；<br>eg:<bean> 标签下配置<constructor-arg ref="引用的bean id"><br>前提是该bean注入的值是引用的bean对象类型，另外还可以是基本数据类型的注入，包括集合；<br>eg:<br><strong>基本数据类型</strong>:</constructor-arg></bean></p><pre><code>&lt;constructor-arg index=&quot;0&quot; type=&quot;java.lang.String&quot; value=&quot;1&quot;/&gt;&lt;/constructor-arg&gt;&lt;constructor-arg index=&quot;1&quot; type=&quot;java.lang.Integer&quot; value=&quot;2&quot;&gt;&lt;/constructor-arg&gt;</code></pre></li></ul><p><strong>集合</strong>:</p><pre><code>&lt;bean id=&quot;xxxx&quot; class=&quot;com.xxxx.xxxx&quot; &gt;        &lt;property name=&quot;arrayData&quot;&gt;            &lt;array/list/set&gt;                &lt;value&gt;xxx&lt;/value&gt;                &lt;value&gt;aaa&lt;/value&gt;                &lt;value&gt;bbb&lt;/value&gt;                &lt;value&gt;ccc&lt;/value&gt;            &lt;/array/list/set&gt;        &lt;/property&gt;&lt;/bean&gt;&lt;property name=&quot;mapData&quot;&gt;    &lt;map&gt;        &lt;entry key=&quot;jack&quot; value=&quot;杰克&quot;&gt;&lt;/entry&gt;        &lt;entry&gt;            &lt;key&gt;&lt;value&gt;rose&lt;/value&gt;&lt;/key&gt;            &lt;value&gt;肉丝&lt;/value&gt;        &lt;/entry&gt;    &lt;/map&gt;&lt;/property&gt;&lt;property name=&quot;propsData&quot;&gt;    &lt;props&gt;        &lt;prop key=&quot;xxxx&quot;&gt;xxxx&lt;/prop&gt;        &lt;prop key=&quot;aaaa&quot;&gt;aaaa&lt;/prop&gt;        &lt;prop key=&quot;bbbb&quot;&gt;bbbb&lt;/prop&gt;    &lt;/props&gt;&lt;/property&gt;</code></pre><ul><li><p>基于注解的注入；<br>使用注解实现ioc的方法，首先记得要配置spring context 的命名空间，并且在applicationContext.xml中配置扫描的含有注解的包；<br>eg:</p><pre><code>&lt;context:component-scan base-package=&quot;xxx.xxxx.xxxx&quot;/&gt;</code></pre></li></ul><p>####5.Spring aop的理解，底层实现原理</p><p>以下给出一段代码解释：<br>当实现日志控制时，</p><pre><code>//将织入类交给spring bean处理&lt;bean id=&quot;loggingAspect&quot; class=&quot;com.cyy.maven.core.Aspect.LoggingAspect&quot;/&gt;&lt;aop:config&gt;    //定义切入点    &lt;aop:pointcut id=&quot;serviceOpearation&quot; expression=&quot;execution(* com.cyy.maven.core.service.impl.*.*(..))&quot;/&gt;    //引用切入点    &lt;aop:aspect  ref=&quot;loggingAspect&quot;&gt;    //使用切入点中的方法织入        &lt;aop:before method=&quot;beforeMethod&quot; pointcut-ref=&quot;serviceOpearation&quot;/&gt;        &lt;aop:after method=&quot;afterMethod&quot; pointcut-ref=&quot;serviceOpearation&quot;/&gt;        &lt;aop:after-returning method=&quot;afterReturning&quot; pointcut-ref=&quot;serviceOpearation&quot; returning=&quot;result&quot;/&gt;        &lt;aop:after-throwing method=&quot;afterThrowing&quot; pointcut-ref=&quot;serviceOpearation&quot; throwing=&quot;e&quot;/&gt;        //环绕方法，等价于以上4个的作用        &lt;aop:around method=&quot;aroundMethod&quot; pointcut-ref=&quot;serviceOpearation&quot;/&gt;    &lt;/aop:aspect&gt;&lt;/aop:config&gt;</code></pre><p>####6.&nbsp;Set和Map的区别</p><ul><li>Set是Collection接口下的子接口，Set中的数据可以是无序的，不可以重复，Set的形式是set<type>  myset，即节点是一个type类型的数据；</type></li><li>Map 是跟Collection同级别的集合接口，Map的形式是map&lt;type1,type2&gt; mymap,即节点数据是一对数据，以键值对的形式存在，key唯一，value可以重复；<br>最基础的回答可以是这样，以后会专门写一篇来对集合这种数据类型进行深入浅出的研究；</li></ul><p>####7.&nbsp;对数据库索引的理解，会举例考察你<br>这个可以参考我之前写过的一篇文章<a href="https://www.jianshu.com/p/b82f2926d9e5" target="_blank" rel="noopener">Mysql 索引的具体优化策略</a></p><p>####8.&nbsp;方法覆盖和重载的区别</p><ul><li>方法覆盖又叫方法重写，是重写父类的办法，权限不能更小，抛出的异常不能更多；</li><li>重载是同一个类中可以有相同名字的方法，但是由于方法参数的类型，顺序，个数不尽相同的相同名称的方法；</li></ul><p>####9.&nbsp;数据库事务的4个特性，最好能说出详细的特征<br>这个可以参考我之前写过的一篇文章<a href="https://www.jianshu.com/p/3e7c12a1a2be" target="_blank" rel="noopener">spring 事务理解</a></p><p>####10.&nbsp;讲讲数据结构中的栈，堆，队列的理解（就是对各种数据结构的理解）</p><p>####11.&nbsp;10000个String对象的去重<br><strong>tips</strong>: 可以使用HashSet解决；</p><p>####12.&nbsp;String对象的取值范围<br>定长的String数据类型占用的存储空间为字符串的长度，取值范围为1——65400个字符;</p><p>####13&nbsp;TCP建立连接 3次握手，结束时4次挥手原理具体内容</p><p>####14.&nbsp;ThreadLocal使用过吗，你来说说对它的理解</p><p>####15.&nbsp;说说数据库内连接，左外连接，右外连接的理解<br>这个可以参考我之前写过的一篇文章<a href="https://www.jianshu.com/p/83d84d7df306" target="_blank" rel="noopener">mysql 连接</a></p><p>####16.&nbsp;Session和Cookie的区别</p><p>####17.&nbsp;StringBuffer和StringBuild的区别和含义</p><ul><li>StringBuffer:每次都对对象本身进行操作，而不是生成新的对象。所以在字符串内容不断改变的情况，建议使用StringBuffer。</li><li>String对象的字符串拼接其实是被JVM解释成了StringBuffer对象的拼接，所以这些时候String对象的速度并不会比StringBuffer慢。</li><li>StringBuild: 区别在于,StringBuffer是线程安全的类。StringBuild不是线程安全的类，在单线程中性能要比StringBuffrer高。</li></ul><p>####18.&nbsp;熟悉设计模式吗，说说你对java设计模式的了解</p><p>####19.&nbsp;mysql  in 和exists的区别<br>这个可以参考我之前写过的一篇文章<a href="https://www.jianshu.com/p/2138cbdeea34" target="_blank" rel="noopener">MySQL中exists和in的区别及使用场景</a></p><p>####20.&nbsp;请介绍你参与的印象最深刻的一个项目，为什么？并且介绍你在项目中的角色和发挥的作用</p><p>####21.&nbsp;你对我们有什么想要提问的吗</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;：本人有幸在boss直聘上获得一次阿里巴巴国际技术事业部的电话面试机会，由于太突然，大部分问题都没有发挥原来的水平，诶，决定痛下决心好好总结，还有就是坚定下自己的目标=_=。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nb</summary>
      
    
    
    
    <category term="后端" scheme="https://seasand1024.github.io/categories/后端/"/>
    
    
    <category term="面试" scheme="https://seasand1024.github.io/tags/面试/"/>
    
  </entry>
  
  <entry>
    <title>mysql 连接</title>
    <link href="https://seasand1024.github.io/2021/06/17/mysql-%E8%BF%9E%E6%8E%A5/"/>
    <id>https://seasand1024.github.io/2021/06/17/mysql-%E8%BF%9E%E6%8E%A5/</id>
    <published>2021-06-17T13:38:47.000Z</published>
    <updated>2021-06-17T13:43:38.779Z</updated>
    
    <content type="html"><![CDATA[<p>####1.内连接<br>内连接是连接的几个表之间完全匹配的记录；<br>基本格式为select a.*,b.* from a inner join b on a.id=b.id</p><p>####2.左外连接<br>左外连接是连接的几个表之间以左边为基准的连接，即左边的记录右边没有的会显示为空；<br>基本格式为select a.*,b.* from a left (outer) join b on a.id=b.id</p><p>####3.右外连接<br>右外连接是连接的几个表之间以右边为基准的连接，即左外连接的逆向，即右边的记录左边没有的会显示为空；<br>基本格式为select a.*,b.* from a right (outer) join b on a.id=b.id </p><p>####4.全连接<br>全连接是几个表之间的记录是返回左表和右表中的所有行。<br>如果某行在另一个表中没有匹配行，则另一个表的选择列表的匹配行赋为空值，如果表之间有匹配行，则整个结果集行包含基表的数据值。<br>基本格式为select a.*,b.* from a full (outer) join b on a.id=b.id</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;####1.内连接&lt;br&gt;内连接是连接的几个表之间完全匹配的记录；&lt;br&gt;基本格式为select a.*,b.* from a inner join b on a.id=b.id&lt;/p&gt;
&lt;p&gt;####2.左外连接&lt;br&gt;左外连接是连接的几个表之间以左边为基准的连接，即左边</summary>
      
    
    
    
    <category term="后端" scheme="https://seasand1024.github.io/categories/后端/"/>
    
    
    <category term="mysql" scheme="https://seasand1024.github.io/tags/mysql/"/>
    
    <category term="SQL" scheme="https://seasand1024.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL中exists和in的区别及使用场景</title>
    <link href="https://seasand1024.github.io/2021/06/17/MySQL%E4%B8%ADexists%E5%92%8Cin%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>https://seasand1024.github.io/2021/06/17/MySQL%E4%B8%ADexists%E5%92%8Cin%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</id>
    <published>2021-06-17T13:35:00.000Z</published>
    <updated>2021-06-17T13:36:17.923Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>1.对B查询涉及id，使用索引，故B表效率高，可用大表 –&gt;外小内大<br>select <em> from A where exists (select </em> from B where A.id=B.id);</p></blockquote><blockquote><p>2.对A查询涉及id，使用索引，故A表效率高，可用大表 –&gt;外大内小<br>select * from A where A.id in (select id from B);</p></blockquote><ol><li><p>exists是对外表做loop循环，每次loop循环再对内表（子查询）进行查询，那么因为对内表的查询使用的索引（内表效率高，故可用大表），而外表有多大都需要遍历，不可避免（尽量用小表），故内表大的使用exists，可加快效率；</p></li><li><p>in是把外表和内表做hash连接，先查询内表，再把内表结果与外表匹配，对外表使用索引（外表效率高，可用大表），而内表多大都需要查询，不可避免，故外表大的使用in，可加快效率。</p></li><li><p>如果用not in ，则是内外表都全表扫描，无索引，效率低，可考虑使用not exists，也可使用A left join B on A.id=B.id where B.id is null 进行优化。</p></li></ol><p>　　此外，新近遇到的坑，mysql版本问题：</p><p>　　MySQL版本问题：5.6.5优化了子查询，引入物化子查询(针对where clause的subquery)，子查询物化将子查询结果存入临时表，确保子查询只执行一次，该表不记录重复数据且采用哈希索引查找;</p><p>而之前的版本则会把非相关子查询转化为相关子查询，导致效率低下（尤其是子查询是小表，外表是大表的情况下，效率变慢许多）。　</p><p>　相关子查询：子查询依赖外层连接的返回值；</p><p>　　非相关子查询：子查询不依赖外层连接的返回值；</p><p>　　子查询分两种，from语句（派生表）和where语句（子查询），派生表的效率要高一些，5.6的优化就是把where语句变成from语句。</p><p>　　本来是内表小，用的in，但是据说5.6之前的版本会把非相关子查询改为相关子查询，就是把in的语句改成了exists的，结果效率超低。</p><p>　　实验说明：派生表join比派生表的速度还要快。而使用in查询需要很多分钟还没有查出来。　</p><blockquote><p>#使用派生表 4.68秒<br>SELECT id FROM la WHERE cardid IN (<br>SELECT cardid FROM (<br>select cardid from la group by cardid having count(1)&gt;50) a) ;<br>#使用派生表的内连接 1.26秒<br>SELECT id FROM la JOIN (<br>select cardid from la group by cardid having count(1)&gt;50) a ON la.cardid=a.cardid;</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;1.对B查询涉及id，使用索引，故B表效率高，可用大表 –&amp;gt;外小内大&lt;br&gt;select &lt;em&gt; from A where exists (select &lt;/em&gt; from B where A.id=B.id);&lt;/p&gt;
&lt;/blockq</summary>
      
    
    
    
    <category term="后端" scheme="https://seasand1024.github.io/categories/后端/"/>
    
    
    <category term="mysql" scheme="https://seasand1024.github.io/tags/mysql/"/>
    
    <category term="SQL" scheme="https://seasand1024.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="https://seasand1024.github.io/2021/06/17/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://seasand1024.github.io/2021/06/17/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2021-06-17T13:33:00.000Z</published>
    <updated>2021-06-17T13:35:06.373Z</updated>
    
    <content type="html"><![CDATA[<p>? 通配符匹配文件名中的 0 个或 1 个字符</p><ul><li>通配符匹配零个或多个字符</li></ul><p>^ 为匹配输入字符串的开始位置。</p><p>[0-9]+匹配多个数字， [0-9] 匹配单个数字，+ 匹配一个或者多个。</p><p>abc$匹配字母 abc 并以 abc 结尾，$ 为匹配输入字符串的结束位置。</p><p>runoo+b，可以匹配 runoob、runooob、runoooooob 等，+ 号代表前面的字符必须至少出现一次（1次或多次）。</p><p>runoo<em>b，可以匹配 runob、runoob、runoooooob 等，</em> 号代表字符可以不出现，也可以出现一次或者多次（0次、或1次、或多次）。</p><p>colou?r 可以匹配 color 或者 colour，? 问号代表前面的字符最多只可以出现一次（0次、或1次）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;? 通配符匹配文件名中的 0 个或 1 个字符&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通配符匹配零个或多个字符&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;^ 为匹配输入字符串的开始位置。&lt;/p&gt;
&lt;p&gt;[0-9]+匹配多个数字， [0-9] 匹配单个数字，+ 匹配一个或者多个。&lt;/p&gt;
&lt;p&gt;abc</summary>
      
    
    
    
    <category term="后端" scheme="https://seasand1024.github.io/categories/后端/"/>
    
    
    <category term="正则匹配" scheme="https://seasand1024.github.io/tags/正则匹配/"/>
    
  </entry>
  
  <entry>
    <title>python 时间序列处理</title>
    <link href="https://seasand1024.github.io/2021/06/17/python-%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E5%A4%84%E7%90%86/"/>
    <id>https://seasand1024.github.io/2021/06/17/python-%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E5%A4%84%E7%90%86/</id>
    <published>2021-06-17T13:31:00.000Z</published>
    <updated>2021-06-17T13:32:12.477Z</updated>
    
    <content type="html"><![CDATA[<p>数据说明：’./data/raw/pm25.csv’文件为某地2017年一段时间内的PM2.5的每小时监测数据，数据按时间顺序记录（从2017-01-01 00:00:00开始，中间不间断），由于各种原因造成了某些时刻的数据缺失。</p><p>要求：</p><p>1.利用已有的记录数据进行建模，将缺失值填充完整，评估指标采用RMSE、MAE和；</p><p>2.尝试多种方法进行建模，对比各种模型的性能;</p><p>3.希望你不要直接用中值、均值、前一时刻、后一时刻等常数填充法进行填充（方法对比中可用做简单对比，如表 2所示）；</p><p>4.将数据填充完整后保存至’pm25_predicted.csv’文件（只保存缺失时刻的数据，不按要求则作废），数据格式如表 3所示（列名、文件名不按要求则作废）。</p><p>题解：</p><p>（1）完成时间序列缺失数据填充，一般来说有如下几种方式：常数填充有均值填充，中位数填充，众数填充，前一时刻和后一时刻填充，传统回归模型方式有自回归模型，移动平均模型，自回归移动平均模型和差分自回归移动平均模型，一般采用插值法填充数据，插值办法一般有滑动平均插值，线性插值，拉格朗日多项式插值；</p><p>（2）每个函数对应一种办法，先将数据用pandas从csv文件中读取为df,然后进行数据插值的算法操作，最后将插值后的数据集用matplotlib呈现出来，最后将插值的数据转化为df，用pandas重新写回csv之中；</p><p>代码：</p><p>1.time_series_fill.py</p><h1 id="coding-utf-8"><a href="#coding-utf-8" class="headerlink" title="-- coding:utf-8 --"></a>-<em>- coding:utf-8 -</em>-</h1><p>from pandas.compat import reduce</p><p><strong>author</strong> = ‘gin.chen’</p><p>import pandas as pd</p><p>import numpy as np</p><p>import matplotlib.pyplot as plt</p><p>from scipy.interpolate import lagrange</p><h1 id="from-fbprophet-import-Prophet"><a href="#from-fbprophet-import-Prophet" class="headerlink" title="from fbprophet import Prophet"></a>from fbprophet import Prophet</h1><p>#</p><h1 id="加载数据"><a href="#加载数据" class="headerlink" title="加载数据"></a>加载数据</h1><p>def load_data():</p><pre><code>df = pd.read_csv(&apos;F:/muke/super_mali/data/raw/pm25.csv&apos;)# return df.head(100)return df</code></pre><h1 id="画散点图"><a href="#画散点图" class="headerlink" title="画散点图"></a>画散点图</h1><p>def draw_scatte_diagram(df):</p><pre><code>plt.plot(df[&apos;index&apos;].to_list(), df[&apos;PM2.5&apos;].to_list())plt.show()</code></pre><h1 id="均值填充"><a href="#均值填充" class="headerlink" title="均值填充"></a>均值填充</h1><p>def mean_method():</p><pre><code>df = load_data()df.fillna(df[&apos;PM2.5&apos;].mean(), inplace=True)draw_scatte_diagram(df)</code></pre><h1 id="中位数填充"><a href="#中位数填充" class="headerlink" title="中位数填充"></a>中位数填充</h1><p>def median_method():</p><pre><code>df = load_data()df.fillna(df[&apos;PM2.5&apos;].median(), inplace=True)draw_scatte_diagram(df)</code></pre><h1 id="众数填充"><a href="#众数填充" class="headerlink" title="众数填充"></a>众数填充</h1><p>def mode_method():</p><pre><code>df = load_data()df.fillna(df[&apos;PM2.5&apos;].mode(), inplace=True)draw_scatte_diagram(df)</code></pre><h1 id="前一时刻填充"><a href="#前一时刻填充" class="headerlink" title="前一时刻填充"></a>前一时刻填充</h1><p>def ffill_method():</p><pre><code>df = load_data()df[&apos;PM2.5&apos;].fillna(method=&apos;ffill&apos;, inplace=True)draw_scatte_diagram(df)</code></pre><h1 id="后一时刻填充"><a href="#后一时刻填充" class="headerlink" title="后一时刻填充"></a>后一时刻填充</h1><p>def bfill_method():</p><pre><code>df = load_data()df[&apos;PM2.5&apos;].fillna(method=&apos;bfill&apos;, inplace=True)draw_scatte_diagram(df)</code></pre><h1 id="前后时刻平均值插值"><a href="#前后时刻平均值插值" class="headerlink" title="前后时刻平均值插值"></a>前后时刻平均值插值</h1><p>def mean_by_before_after_method():</p><pre><code>df = load_data()# data_index = df[&apos;index&apos;].to_list()# data_value = df[&apos;PM2.5&apos;].to_list()fill = []for i in range(len(df)):    if np.math.isnan(df.iloc[i - 1][1]):        left = df.iloc[i - 2][1]        for j in range(i, len(df)):            if np.math.isnan(df.iloc[j][1]):                continue            else:                right = df.iloc[j][1]                break        df.iloc[i - 1, 1] = (left + right) / 2        fill_tuple = i, df.iloc[i - 1][1]        fill.append(fill_tuple)draw_scatte_diagram(df)df = pd.DataFrame(fill, columns=[&apos;index&apos;, &apos;PM2.5&apos;])df.to_csv(&apos;pm25_predicted_mean.csv&apos;, index=False)</code></pre><h1 id="线性插值详细"><a href="#线性插值详细" class="headerlink" title="线性插值详细"></a>线性插值详细</h1><p>def linear_detail(x1, y1, x2, y2):</p><pre><code>k = (y2 - y1) / (x2 - x1)b = y1 - k * x1return lambda x: b + k * x</code></pre><h1 id="线性插值"><a href="#线性插值" class="headerlink" title="线性插值"></a>线性插值</h1><p>def linear_method():</p><pre><code># global jdf = load_data()fill = []for i in range(len(df)):    if np.isnan(df.iloc[i][1]):        for j in range(i, len(df)):            if np.isnan(df.iloc[j][1]):                continue            else:                break        df.iloc[i, 1] = (linear_detail(i, df.iloc[i - 1][1], j + 1, df.iloc[j][1]))(i + 1)        fill_tuple = i + 1, df.iloc[i][1]        fill.append(fill_tuple)draw_scatte_diagram(df)df = pd.DataFrame(fill, columns=[&apos;index&apos;, &apos;PM2.5&apos;])df.to_csv(&apos;pm25_predicted_linear.csv&apos;, index=False)</code></pre><h1 id="平滑插值详细"><a href="#平滑插值详细" class="headerlink" title="平滑插值详细"></a>平滑插值详细</h1><p>def smooth_detail(series, pos, window=5):</p><pre><code>&quot;&quot;&quot;:param series: 列向量:param pos: 被插值的位置:param window: 为取前后的数据个数:return:&quot;&quot;&quot;y = series[list(range(pos - window, pos)) + list(range(pos + 1, pos + 1 + window))]  # 取数y = y[y.notnull()]return reduce(lambda a, b: a + b, y) / len(y)</code></pre><h1 id="平滑插值"><a href="#平滑插值" class="headerlink" title="平滑插值"></a>平滑插值</h1><p>def smooth_method(show=1):</p><pre><code>df_raw = load_data()df = df_raw[&apos;PM2.5&apos;].copy()full = []for j in range(len(df)):    if (df.isnull())[j]:  # 如果为空即插值。        df[j] = smooth_detail(df, j)        df_raw.loc[j, &apos;PM2.5&apos;] = df[j]        # print(j, df_raw.loc[j, &apos;index&apos;], df_raw.loc[j, &apos;PM2.5&apos;])        full_tuple = df_raw.loc[j, &apos;index&apos;], df_raw.loc[j, &apos;PM2.5&apos;]        full.append(full_tuple)if show:    draw_scatte_diagram(df_raw)    df = pd.DataFrame(full, columns=[&apos;index&apos;, &apos;PM2.5&apos;])    df.to_csv(&apos;pm25_predicted_smooth.csv&apos;, index=False)return df_raw</code></pre><h1 id="拉格朗日插值详细"><a href="#拉格朗日插值详细" class="headerlink" title="拉格朗日插值详细"></a>拉格朗日插值详细</h1><p>def lagrange_detail(series, pos, window=5):</p><pre><code>&quot;&quot;&quot;:param series: 列向量:param pos: 被插值的位置:param window: 为取前后的数据个数:return:&quot;&quot;&quot;y = series[list(range(pos - window, pos)) + list(range(pos + 1, pos + 1 + window))]  # 取数y = y[y.notnull()]  # 剔除空值return lagrange(y.index, list(y))(pos)  # 插值并返回插值结果</code></pre><h1 id="拉格朗日插值"><a href="#拉格朗日插值" class="headerlink" title="拉格朗日插值"></a>拉格朗日插值</h1><p>def lagrange_method():</p><pre><code>df_raw = load_data()df = df_raw[&apos;PM2.5&apos;].copy()full = []for j in range(len(df)):    if (df.isnull())[j]:  # 如果为空即插值。        df[j] = lagrange_detail(df, j)        df_raw.loc[j, &apos;PM2.5&apos;] = df[j]        # print(j, df.loc[j, &apos;index&apos;], df[j])        full_tuple = df_raw.loc[j, &apos;index&apos;], df_raw.loc[j, &apos;PM2.5&apos;]        full.append(full_tuple)draw_scatte_diagram(df_raw)df = pd.DataFrame(full, columns=[&apos;index&apos;, &apos;PM2.5&apos;])df.to_csv(&apos;pm25_predicted_lagrange.csv&apos;, index=False)</code></pre><h1 id="计算RMSE"><a href="#计算RMSE" class="headerlink" title="计算RMSE"></a>计算RMSE</h1><p>def calculate_RMSE(target, prediction):</p><pre><code>error = []for i in range(len(target)):    error.append(target[i] - prediction[i])return (sum([n * n for n in error]) / len(error)) ** 0.5</code></pre><h1 id="计算MAE"><a href="#计算MAE" class="headerlink" title="计算MAE"></a>计算MAE</h1><p>def calculate_MAE(target, prediction):</p><pre><code>error = []for i in range(len(target)):    error.append(target[i] - prediction[i])return sum([abs(n) for n in error]) / len(error)</code></pre><h1 id="计算R-square"><a href="#计算R-square" class="headerlink" title="计算R-square"></a>计算R-square</h1><p>def calculate_R_Square(target, prediction):</p><pre><code>error = []a = calculate_MAE(target, prediction) * len(error)mean = np.mean(np.array(target))for i in range(len(target)):    error.append(prediction[i] - mean)b = sum([n * n for n in error])return 1 - a / b</code></pre><p>if <strong>name</strong> == ‘<strong>main</strong>‘:</p><pre><code># mean_method()# median_method()# mode_method()# ffill_method()# bfill_method()# mean_by_before_after_method()# linear_method()# lagrange_method()smooth_method()</code></pre><p>2.fbprophet_fill.py</p><h1 id="coding-utf-8-1"><a href="#coding-utf-8-1" class="headerlink" title="-- coding:utf-8 --"></a>-<em>- coding:utf-8 -</em>-</h1><p>from pandas.io.sas.sas7bdat import _column</p><p>from time_series_fill import smooth_method</p><p><strong>author</strong> = ‘gin.chen’</p><p>import pandas as pd</p><p>import numpy as np</p><p>import matplotlib.pyplot as plt</p><p>import datetime</p><p>from fbprophet import Prophet</p><p>if <strong>name</strong> == ‘<strong>main</strong>‘:</p><pre><code>def load_data():    # df = pd.read_csv(&apos;F:/muke/super_mali/data/raw/pm25.csv&apos;)    # return df.head(100)    df = smooth_method(0)    return df.head(3129)df = load_data()first_value = datetime.datetime.strptime(&apos;2017-01-01 00:00:00&apos;, &apos;%Y-%m-%d %H:%M:%S&apos;)for i in range(len(df)):    df.iloc[i, 0] = (first_value + datetime.timedelta(hours=i)).strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)# df = pd.DataFrame(, columns=[&apos;ds&apos;, &apos;y&apos;])# df.to_csv(&apos;pm25_predicted_mean.csv&apos;, index=False)# print(df.iloc[1,0])df.rename(columns={&apos;index&apos;: &apos;ds&apos;, &apos;PM2.5&apos;: &apos;y&apos;}, inplace=True)m = Prophet()# df[&apos;y&apos;] = np.log(df[&apos;y&apos;])df = m.fit(df)future = m.make_future_dataframe(freq=&apos;H&apos;, periods=5428)future.tail()forecast = m.predict(future)forecast[[&apos;ds&apos;, &apos;yhat&apos;, &apos;yhat_lower&apos;, &apos;yhat_upper&apos;]].tail()fig1 = m.plot(forecast)fig2 = m.plot_components(forecast)plt.show()</code></pre><p>运行结果图：</p><p>Mean</p><p>Median</p><p>Ffill_method </p><p>Bfill_method </p><p>Linear_method </p><p>lagrange_method</p><p>smooth_method</p><p>Fbprophet实现 </p><p>日，周，月的趋势<br>未完待续。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;数据说明：’./data/raw/pm25.csv’文件为某地2017年一段时间内的PM2.5的每小时监测数据，数据按时间顺序记录（从2017-01-01 00:00:00开始，中间不间断），由于各种原因造成了某些时刻的数据缺失。&lt;/p&gt;
&lt;p&gt;要求：&lt;/p&gt;
&lt;p&gt;1.利</summary>
      
    
    
    
    <category term="数据分析" scheme="https://seasand1024.github.io/categories/数据分析/"/>
    
    
    <category term="python" scheme="https://seasand1024.github.io/tags/python/"/>
    
    <category term="时间序列处理" scheme="https://seasand1024.github.io/tags/时间序列处理/"/>
    
  </entry>
  
  <entry>
    <title>flink 理解</title>
    <link href="https://seasand1024.github.io/2021/06/17/flink-%E7%90%86%E8%A7%A3/"/>
    <id>https://seasand1024.github.io/2021/06/17/flink-%E7%90%86%E8%A7%A3/</id>
    <published>2021-06-17T13:27:00.000Z</published>
    <updated>2021-06-17T13:29:30.843Z</updated>
    
    <content type="html"><![CDATA[<p>统一的批处理与流处理系统</p><p>在大数据处理领域，批处理任务与流处理任务一般被认为是两种不同的任务，一个大数据项目一般会被设计为只能处理其中一种任务，例如Apache Storm、Apache Smaza只支持流处理任务，而Aapche MapReduce、Apache Tez、Apache Spark只支持批处理任务。Spark Streaming是Apache Spark之上支持流处理任务的子系统，看似一个特例，实则不然——Spark Streaming采用了一种micro-batch的架构，即把输入的数据流切分成细粒度的batch，并为每一个batch数据提交一个批处理的Spark任务，所以Spark Streaming本质上还是基于Spark批处理系统对流式数据进行处理，和Apache Storm、Apache Smaza等完全流式的数据处理方式完全不同。通过其灵活的执行引擎，Flink能够同时支持批处理任务与流处理任务。</p><p>在执行引擎这一层，流处理系统与批处理系统最大不同在于节点间的数据传输方式。对于一个流处理系统，其节点间数据传输的标准模型是：当一条数据被处理完成后，序列化到缓存中，然后立刻通过网络传输到下一个节点，由下一个节点继续处理。而对于一个批处理系统，其节点间数据传输的标准模型是：当一条数据被处理完成后，序列化到缓存中，并不会立刻通过网络传输到下一个节点，当缓存写满，就持久化到本地硬盘上，当所有数据都被处理完成后，才开始将处理后的数据通过网络传输到下一个节点。这两种数据传输模式是两个极端，对应的是流处理系统对低延迟的要求和批处理系统对高吞吐量的要求。Flink的执行引擎采用了一种十分灵活的方式，同时支持了这两种数据传输模型。Flink以固定的缓存块为单位进行网络数据传输，用户可以通过缓存块超时值指定缓存块的传输时机。如果缓存块的超时值为0，则Flink的数据传输方式类似上文所提到流处理系统的标准模型，此时系统可以获得最低的处理延迟。如果缓存块的超时值为无限大，则Flink的数据传输方式类似上文所提到批处理系统的标准模型，此时系统可以获得最高的吞吐量。同时缓存块的超时值也可以设置为0到无限大之间的任意值。缓存块的超时阈值越小，则Flink流处理执行引擎的数据处理延迟越低，但吞吐量也会降低，反之亦然。通过调整缓存块的超时阈值，用户可根据需求灵活地权衡系统延迟和吞吐量。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;统一的批处理与流处理系统&lt;/p&gt;
&lt;p&gt;在大数据处理领域，批处理任务与流处理任务一般被认为是两种不同的任务，一个大数据项目一般会被设计为只能处理其中一种任务，例如Apache Storm、Apache Smaza只支持流处理任务，而Aapche MapReduce、Apac</summary>
      
    
    
    
    <category term="数据开发" scheme="https://seasand1024.github.io/categories/数据开发/"/>
    
    
    <category term="flink" scheme="https://seasand1024.github.io/tags/flink/"/>
    
  </entry>
  
  <entry>
    <title>Griffin POC</title>
    <link href="https://seasand1024.github.io/2021/06/17/Griffin-POC/"/>
    <id>https://seasand1024.github.io/2021/06/17/Griffin-POC/</id>
    <published>2021-06-17T13:18:00.000Z</published>
    <updated>2021-06-17T13:25:06.152Z</updated>
    
    <content type="html"><![CDATA[<pre><code>Apache Griffin是一个应用于分布式数据系统中的开源数据质量解决方案。在Hadoop, Spark, Storm等分布式系统中，提供了一整套统一的流程来定义和检测数据集的质量并及时报告问题。</code></pre><p>Apache Griffin填补了开源世界里在大数据质量领域的空白。就像空气质量，水和食品安全等无时不刻地在影响人类的生命一样，数据质量在数据科学领域是至关重要的。在大数据时代，企业决策调整，商机发现等越来越依赖于大数据的数据分析和数据挖掘，而数据质量的保证是所有一切数据分析和数据挖掘的基础。</p><p>系统架构：</p><p>Griffin架构图<br>1.apache griffin  安装配置；</p><p>从官网下载最新版本<a href="http://griffin.apache.org/docs/latest.html，源码版本进行编译安装；" target="_blank" rel="noopener">http://griffin.apache.org/docs/latest.html，源码版本进行编译安装；</a></p><p>2.(1)配置measure组件；</p><pre><code>配置env-batch.json中hdfs和es的path,分别为&quot;hdfs://10.2.29.101:8020/griffin/batch/persist&quot;,&quot;http://10.2.29.102:9200/griffin/accuracy&quot;,env-streaming.json类似，env-streaming.json还要配置zk的host为“10.2.29.101:2181“，其他默认；配置config-batch.json，config-streaming.json其中的sinks至少要有es，配置config-batch-advanced.json[&quot;HDFS&quot;,&quot;ELASTICSEARCH&quot;,&quot;CONSOLE&quot;]，运行maven命令，mvn clean package -Dmaven.test.skip=true;</code></pre><p>   (2)配置service组件；</p><pre><code>配置env下env_streaming.json，env_batch.json，配置同measure;配置application.properties，配置端口为9270，server.port=9270；配置quartz数据库，进入postgres用户下bin目录下，createdb -O &lt;username&gt; quartz，将项目中的Init_quartz_postgres.sql quartz拷贝到一个目录，psql -p &lt;port&gt; -h &lt;host address&gt; -U &lt;username&gt; -f Init_quartz_postgres.sql quartz；配置spring.datasource为相应的数据库quartz，设置用户名密码，设置相应数据库驱动，设置hive.metastore.uris=thrift://en1-dev1-tbdp.trendy-global.com:9083，hive.metastore.dbname=default，kafka.schema.registry.url=http://en1- dev1-tbdp.trendy-global.com:6667，fs.defaultFS=hdfs://nn1-dev1-tbdp.trendy-global.com:8020，elasticsearch.host=10.2.29.102，elasticsearch.port=9200，livy.uri=http://en1-dev1-tbdp.trendy-global.com:8999/batches，yarn.uri=http://en1-dev1-tbdp.trendy-global.com:8088；配置sparkProperties.json，如下：</code></pre><p>{</p><p>   “file”: “hdfs:///griffin/griffin-measure.jar”,</p><p>   “className”: “org.apache.griffin.measure.Application”,</p><p>   “name”: “griffin”,</p><p>   “queue”: “default”,</p><p>   “numExecutors”: 3,</p><p>   “executorCores”: 1,</p><p>   “driverMemory”: “1g”,</p><p>   “executorMemory”: “1g”,</p><p>   “files”: [ “hdfs:///livy/hive-site.xml” ]</p><p>}；</p><pre><code>然后在service根目录下运行maven命令，mvn clean package -Dmaven.test.skip=true;将measure组件按照sparkProperties.json配置的丢到hdfs上；</code></pre><p>   (3)配置ui组件；</p><pre><code>配置ui/angular/src/app/service/service.service.ts文件public BACKEND_SERVER = &apos;http://localhost:9270&apos;;为之前service的端口；在angular下运行命令npm run build </code></pre><p>3.运行；</p><p>  （1）启动service组件，命令：</p><p>java -jar -Dserver.port=9270 -Dfs.defaultFS=hdfs:///griffin/persist service-0.3.0-incubating.jar；</p><p>  （2）启动ui 组件，命令：</p><pre><code>在angular下运行命令npm run start或者cd ui/angular ../angular/node_modules/.bin/ng serve --port 9280</code></pre><p>griffin运行界面<br>4.建立数据质量检测方案poc；</p><pre><code>（1）建立accuracy类型检测，点击create measure 按钮，按照操作步骤进行设置，注意设置分区要相对应或者不设置；（2）建立data profiling类型检测，同样按照步骤操作；（3）点击create job根据提示创建job; 结果如图：</code></pre><p>job界面</p><p>job详解界面</p><p>job4</p><p>mea-job1</p>]]></content>
    
    
      
      
    <summary type="html">&lt;pre&gt;&lt;code&gt;Apache Griffin是一个应用于分布式数据系统中的开源数据质量解决方案。在Hadoop, Spark, Storm等分布式系统中，提供了一整套统一的流程来定义和检测数据集的质量并及时报告问题。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Apache Griff</summary>
      
    
    
    
    <category term="数据开发" scheme="https://seasand1024.github.io/categories/数据开发/"/>
    
    
    <category term="数据质量监控" scheme="https://seasand1024.github.io/tags/数据质量监控/"/>
    
  </entry>
  
</feed>
